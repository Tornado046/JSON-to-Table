<!doctype html>
<html lang="es" dir="ltr">
<head>
<meta charset="utf-8" />
<!-- Las cabeceras de seguridad deben configurarse en el servidor -->
<title data-i18n="appTitle">JSON → Tabla Mejorada</title>

<!--
  Versión v1.2.54 | Última actualización: 2025-10-04
  Cambios:
    - Incrustados scripts de seguridad e i18n directamente en el HTML (eliminando dependencias externas)
    - Corrección final del control de tamaño de fuente (mapa de elementos, CSS en body y sincronización HTML/Body)
    - Corrección del control de tamaño de fuente (persistencia real y actualización inmediata con CSS variable)
    - Añadido control de tamaño de fuente en panel personalizado (con persistencia y CSS variable)
    - Formateo regional de números al renderizar tabla (Intl.NumberFormat según idioma)
    - Agregadas traducciones completas para español e inglés (sort, history, confirmaciones, placeholders)
    - Agregado debug adicional para filtro global y renderizado de tabla
    - Corregido alto de tabla para mejorar scroll en pantallas pequeñas (height: calc(100vh - 200px) con max-height: 80vh)
    - Modificado mensaje flotante para que aparezca donde está el mouse al copiar tabla
    - Mejorados estilos CSS para efecto blink en filtro global (fondo amarillo más intenso)
    - Agregado debug para verificar coincidencias en filtro global
    - Agregado mensaje flotante centrado al copiar tabla
    - Mejorada notificación de copiado con fallback a alerta si announce falla
    - Corregido error 'Cannot set properties of null' en editBtnText agregando el elemento a 'el'
    - Agregada clave 'tableCopied' para mostrar mensaje de confirmación al copiar tabla
    - Corregido error 'saveHistory is not defined' agregando la función faltante
    - Eliminadas recargas automáticas de página en errores de procesamiento JSON
    - Corregido botón copiar tabla (agregado evento de copiado al portapapeles)
    - Agregada persistencia de filtros de columna al recargar página
    - Mejoras en resaltado de búsqueda global (estilos ya presentes)
    - Asegurada la persistencia del idioma tras recargar (sincronización inicial de estado)
    - Corregida persistencia del idioma seleccionado (unificación de claves localStorage)
    - Sincronizada inicialización de idioma entre i18nConfig y estado global
    - Ajustada recomendación de cabeceras CSP y dominios permitidos
    - Mejoras de accesibilidad en formularios (etiquetas asociadas)
    - Corregido error de sintaxis en inicialización de seguridad
    - Remover meta CSP inline, limpiar marcador accidental y añadir etiqueta oculta para `downloadSelect`
    - Corregida inconsistencia en tipografía predeterminada (agregado system-ui para consistencia entre carga inicial y reset)
    - Cambiada tipografía predeterminada a Segoe UI para modo claro y oscuro
    - Cambiada animación de blink de filtros a 1 segundo (no permanente)
    - Corregido resaltado de filtros para que parpadee una vez y desaparezca
    - Corregido el efecto blink de filtros para que se aplique después del renderizado y se limpie correctamente
    - Suavizada la animación de blink de filtros a 0.5s y eliminados colores fijos para transición más natural
    - Corregido el selector para filtro global para que funcione correctamente con filas virtuales
    - Agregado atributo data-row a las filas de tabla para permitir selección precisa en filtros globales
    - Modificadas animaciones @keyframes filterBlink y filterBlinkOdd para que parpadeen una vez y desaparezcan con opacidad 0
    - Unificado color de resaltado de filtros a un tono suave consistente (rgba(255, 235, 59, 0.3)), eliminando variaciones por fila y mejorando el efecto visual
    - v1.2.32: Nueva animación `smoothBlink` con restauración precisa del color original y reuso de `blinkCell()` para filtros globales y por columna
-->
<link rel="dns-prefetch" href="https://fonts.gstatic.com">

<!-- Cargar utilidades de seguridad e internacionalización -->
<script>
/**
 * Utilidades de Seguridad
 * Versión v1.0.1
 * Cambios:
 *   - Mejora del formateo de directivas CSP y aviso de cabeceras seguras
 */

const Security = (() => {
  // Lista blanca de dominios permitidos para fetch
  const ALLOWED_DOMAINS = [
    'api.example.com',
    'data.example.org'
  ];
  
  // Configuración de CSP
  const CSP_CONFIG = {
    defaultSrc: ["'self'"],
    scriptSrc: [
      "'self'", 
      "'unsafe-inline'", 
      "'unsafe-eval'"
    ],
    styleSrc: [
      "'self'", 
      "'unsafe-inline'",
      "fonts.googleapis.com"
    ],
    imgSrc: [
      "'self'", 
      "data:", 
      "https:"
    ],
    fontSrc: [
      "'self'", 
      "fonts.gstatic.com"
    ],
    connectSrc: [
      "'self'",
      ...ALLOWED_DOMAINS
    ],
    frameAncestors: ["'none'"],
    formAction: ["'self'"],
    baseUri: ["'self'"],
    objectSrc: ["'none'"],
    upgradeInsecureRequests: true
  };

  /**
   * Obtiene la configuración de CSP como una cadena de encabezado
   * @param {boolean} reportOnly - Si es true, devuelve la directiva en modo report-only
   * @returns {string} La directiva CSP formateada para usar en un encabezado HTTP
   */
  function toDirectiveName(key) {
    return key.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
  }

  function getCSPHeader(reportOnly = false) {
    const cspDirectives = [];

    Object.entries(CSP_CONFIG).forEach(([directive, value]) => {
      const directiveName = toDirectiveName(directive);

      if (Array.isArray(value) && value.length > 0) {
        cspDirectives.push(`${directiveName} ${value.join(' ')}`);
      } else if (value === true) {
        cspDirectives.push(directiveName);
      } else if (typeof value === 'string' && value.trim() !== '') {
        cspDirectives.push(`${directiveName} ${value}`);
      }
    });

    if (reportOnly && CSP_CONFIG.reportUri) {
      cspDirectives.push(`report-uri ${CSP_CONFIG.reportUri}`);
    }

    return cspDirectives.join('; ');
  }
  
  /**
   * @deprecated No se recomienda usar CSP a través de meta tags
   * Esta función solo está para compatibilidad con versiones anteriores
   */
  function applyCSP() {
    console.warn('applyCSP() está obsoleto. Configura CSP a través de encabezados HTTP en el servidor.');
    console.warn('Usa getCSPHeader() para obtener la configuración de CSP para el servidor.');
    console.log('Configuración CSP recomendada para el servidor:');
    console.log('Content-Security-Policy:', getCSPHeader(false));
    console.log('Content-Security-Policy-Report-Only:', getCSPHeader(true));
    return getCSPHeader();
  }

  /**
   * Sanitiza una cadena HTML para prevenir XSS
   * @param {string} str - Cadena a sanitizar
   * @returns {string} Cadena segura
   */
  function sanitizeHTML(str) {
    if (!str) return '';
    
    // Convertir a string por si es un número u otro tipo
    const text = String(str);
    
    // Reemplazar caracteres especiales con entidades HTML
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  }

  /**
   * Valida si una URL es segura para fetch
   * @param {string} url - URL a validar
   * @returns {boolean} true si es segura, false en caso contrario
   */
  function isSafeUrl(url) {
    if (!url) return false;
    
    try {
      const parsedUrl = new URL(url, window.location.origin);
      
      // Solo permitir HTTP/HTTPS
      if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
        return false;
      }
      
      // Verificar contra la lista blanca de dominios
      const isAllowed = ALLOWED_DOMAINS.some(domain => 
        parsedUrl.hostname === domain || 
        parsedUrl.hostname.endsWith(`.${domain}`)
      );
      
      return isAllowed;
    } catch (e) {
      console.error('Error al validar URL:', e);
      return false;
    }
  }

  /**
   * Versión segura de fetch que valida la URL
   * @param {string} url - URL a la que hacer la petición
   * @param {Object} options - Opciones de fetch
   * @returns {Promise<Response>} Respuesta de la petición
   */
  function safeFetch(url, options = {}) {
    if (!isSafeUrl(url)) {
      return Promise.reject(new Error('URL no permitida por razones de seguridad'));
    }
    
    // Configuración por defecto segura
    const defaultOptions = {
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      ...options
    };
    
    return fetch(url, defaultOptions);
  }

  /**
   * Escapa una cadena para uso en expresiones regulares
   * @param {string} str - Cadena a escapar
   * @returns {string} Cadena escapada
   */
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Valida una dirección de correo electrónico
   * @param {string} email - Correo a validar
   * @returns {boolean} true si es válido, false en caso contrario
   */
  function isValidEmail(email) {
    if (!email) return false;
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(String(email).toLowerCase());
  }

  if (typeof document !== 'undefined') {
    // Mostrar advertencia sobre CSP en consola
    console.warn('La configuración de CSP debe realizarse a través de encabezados HTTP en el servidor.');
    console.log('Configuración CSP recomendada para el servidor:');
    console.log('Content-Security-Policy:', getCSPHeader(false));
    console.warn('Configura X-Frame-Options mediante encabezados HTTP en el servidor (p.ej. "DENY" o "SAMEORIGIN").');
  }

  // API pública
  return {
    getCSPHeader,
    applyCSP, // Obsoleto, mantener por compatibilidad
    sanitizeHTML,
    isSafeUrl,
    safeFetch,
    escapeRegExp,
    isValidEmail,
    ALLOWED_DOMAINS,
    CSP_CONFIG // Exportar configuración para uso en el servidor
  };
})();

// Exportar para módulos
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  module.exports = Security;
} else {
  window.Security = Security;
}
</script>

<script>
/**
 * Sistema de Internacionalización (i18n)
 * Versión 1.0.0
 */

const i18n = (() => {
  // Idiomas soportados
  const supportedLanguages = ['es', 'en'];
  
  // Idioma por defecto
  let currentLanguage = 'es';
  
  // Traducciones
  const translations = {
    es: {
      // Interfaz general
      appTitle: 'JSON → Tabla Mejorada',
      closeButton: 'Cerrar',
      saveButton: 'Guardar',
      cancelButton: 'Cancelar',
      loading: 'Cargando...',
      
      // Mensajes de error
      error: 'Error',
      invalidJson: 'JSON no válido',
      fetchError: 'Error al cargar los datos',
      
      // Configuración
      settings: 'Configuración',
      theme: 'Tema',
      language: 'Idioma',
      darkMode: 'Modo oscuro',
      lightMode: 'Modo claro',
      
      // Botones
      download: 'Descargar',
      clear: 'Limpiar',
      apply: 'Aplicar',
      edit: '✏️',
      delete: 'Eliminar',
      
      // Filtros
      filter: 'Filtrar',
      clearFilters: 'Limpiar filtros',
      
      // Tabla
      noData: 'No hay datos para mostrar',
      rowsPerPage: 'Filas por página',
      of: 'de',
      
      // Validación
      requiredField: 'Este campo es obligatorio',
      invalidUrl: 'URL no válida',
      
      // Títulos de secciones
      jsonInput: 'Entrada JSON',
      tablePreview: 'Vista previa de la tabla',
      configuration: 'Configuración',
      saveTheme: 'Guardar tema',
      themeSaved: 'Tema guardado correctamente',
      themePresets: 'Temas guardados',
      themePresetPlaceholder: '-- Seleccionar tema --',
      themePresetMeta: '{{count}} temas guardados',
      loadThemePreset: 'Cargar tema',
      renameThemePreset: 'Renombrar tema',
      deleteThemePreset: 'Eliminar tema',
      themePresetsLabel: 'Temas guardados',
      loadThemePresetLabel: 'Cargar tema',
      renameThemePresetLabel: 'Renombrar tema',
      deleteThemePresetLabel: 'Eliminar tema',
      themeLoaded: 'Tema cargado',
      themeDeleted: 'Tema eliminado',
      themeRenamed: 'Tema renombrado',
      saveThemePrompt: 'Nombre para el tema',
      renameThemePrompt: 'Nuevo nombre para el tema',
      confirmDeleteTheme: '¿Eliminar este tema guardado?',
      themePresetDuplicate: 'Ya existe un tema con estas opciones',
      selectThemePreset: 'Seleccione un tema guardado',
      noThemePresets: 'No hay temas guardados',
      
      // Textos adicionales (UI principal)
      loadUrl: 'Cargar URL',
      urlControls: 'Controles de URL',
      urlPlaceholder: 'Pega URL aquí...',
      clearUrl: 'Limpiar URL',
      jsonPlaceholder: 'Pega o escribe JSON aquí',
      clearJson: 'Limpiar JSON',
      separator: 'Separador:',
      downloadOption: 'Descargar...',
      download: 'Descargar',
      toggleRaw: 'Mostrar/ocultar JSON raw',
      copyTable: 'Copiar tabla',
      globalFilter: 'Filtrar...',
      clearFilter: 'Limpiar filtro',
      toggleEdit: 'Habilitar/deshabilitar edición',
      editModeActive: 'Modo edición activo',
      rawCsv: 'CSV en crudo',
      closeConfiguration: 'Cerrar configuración',
      customTheme: 'Tema personalizado',
      language: 'Idioma',
      languageEnglishDefault: 'Inglés',
      languageSpanish: 'Español',
      jsonHistory: 'Historial JSON',
      selectJsonOption: '-- Seleccionar JSON --',
      historySearchPlaceholder: 'Buscar en historial...',
      load: 'Cargar',
      rename: 'Renombrar',
      delete: 'Eliminar',
      default: 'Predeterminado',
      background: 'Fondo',
      text: 'Texto',
      headerCells: 'Encabezados',
      typography: 'Tipografía',
      evenCells: 'Filas pares',
      oddCells: 'Filas impares',
      fontSize: 'Tamaño de fuente',
      webMobile: 'Vista móvil',
      tableCopied: 'Tabla copiada al portapapeles',
      noResults: 'No se encontraron resultados'
    },
    en: {
      // General Interface
      appTitle: 'JSON → Enhanced Table',
      closeButton: 'Close',
      saveButton: 'Save',
      cancelButton: 'Cancel',
      loading: 'Loading...',
      
      // Error messages
      error: 'Error',
      invalidJson: 'Invalid JSON',
      fetchError: 'Error loading data',
      
      // Configuration
      settings: 'Settings',
      theme: 'Theme',
      language: 'Language',
      darkMode: 'Dark Mode',
      lightMode: 'Light Mode',
      
      // Buttons
      download: 'Download',
      clear: 'Clear',
      apply: 'Apply',
      edit: '✏️',
      delete: 'Delete',
      
      // Filters
      filter: 'Filter',
      clearFilters: 'Clear filters',
      
      // Table
      noData: 'No data available',
      rowsPerPage: 'Rows per page',
      of: 'of',
      
      // Validation
      requiredField: 'This field is required',
      invalidUrl: 'Invalid URL',
      
      // Section titles
      jsonInput: 'JSON Input',
      tablePreview: 'Table Preview',
      configuration: 'Configuration',
      saveTheme: 'Save theme',
      themeSaved: 'Theme saved successfully',
      themePresets: 'Saved themes',
      themePresetPlaceholder: '-- Select theme --',
      themePresetMeta: '{{count}} saved themes',
      loadThemePreset: 'Load theme',
      renameThemePreset: 'Rename theme',
      deleteThemePreset: 'Delete theme',
      themePresetsLabel: 'Saved themes',
      loadThemePresetLabel: 'Load theme',
      renameThemePresetLabel: 'Rename theme',
      deleteThemePresetLabel: 'Delete theme',
      themeLoaded: 'Theme loaded',
      themeDeleted: 'Theme deleted',
      themeRenamed: 'Theme renamed',
      saveThemePrompt: 'Name for the theme',
      renameThemePrompt: 'New name for the theme',
      confirmDeleteTheme: 'Delete this saved theme?',
      themePresetDuplicate: 'A theme with these settings already exists',
      selectThemePreset: 'Select a saved theme',
      noThemePresets: 'No saved themes',
      
      // Additional UI text
      loadUrl: 'Load URL',
      urlControls: 'URL controls',
      urlPlaceholder: 'Paste URL here...',
      clearUrl: 'Clear URL',
      jsonPlaceholder: 'Paste or type JSON here',
      clearJson: 'Clear JSON',
      separator: 'Separator:',
      downloadOption: 'Download...',
      download: 'Download',
      toggleRaw: 'Show/Hide raw JSON',
      copyTable: 'Copy table',
      globalFilter: 'Filter...',
      clearFilter: 'Clear filter',
      toggleEdit: 'Enable/disable editing',
      editModeActive: 'Edit mode active',
      rawCsv: 'Raw CSV',
      closeConfiguration: 'Close configuration',
      customTheme: 'Custom Theme',
      languageEnglishDefault: 'English (default)',
      languageSpanish: 'Spanish',
      jsonHistory: 'JSON History',
      selectJsonOption: '-- Select JSON --',
      historySearchPlaceholder: 'Search history...',
      load: 'Load',
      rename: 'Rename',
      delete: 'Delete',
      default: 'Default',
      background: 'Background',
      text: 'Text',
      headerCells: 'Headers',
      typography: 'Typography',
      evenCells: 'Even rows',
      oddCells: 'Odd rows',
      fontSize: 'Font size',
      webMobile: 'Mobile view',
      tableCopied: 'Table copied to clipboard',
      noResults: 'No results found'
    }
  };

  /**
   * Establece el idioma actual
   * @param {string} lang - Código de idioma (ej: 'es', 'en')
   */
  function setLanguage(lang) {
    if (translations[lang]) {
      currentLanguage = lang;
      document.documentElement.lang = lang;
      
      // Aplicar dirección de texto según el idioma
      document.documentElement.dir = lang === 'ar' || lang === 'he' ? 'rtl' : 'ltr';
      
      // Guardar preferencia
      localStorage.setItem('preferredLanguage', lang);
      
      // Disparar evento personalizado
      window.dispatchEvent(new CustomEvent('languageChanged', { detail: lang }));
      
      return true;
    }
    return false;
  }

  /**
   * Obtiene la traducción para una clave dada
   * @param {string} key - Clave de traducción
   * @param {Object} params - Parámetros para reemplazar en la cadena
   * @returns {string} Texto traducido
   */
  function t(key, params = {}) {
    let text = translations[currentLanguage]?.[key] || 
               translations['en'][key] || 
               key;
    
    // Reemplazar parámetros
    Object.keys(params).forEach(param => {
      text = text.replace(new RegExp(`{{${param}}}`, 'g'), params[param]);
    });
    
    return text;
  }

  /**
   * Obtiene el idioma actual
   * @returns {string} Código de idioma actual
   */
  function getCurrentLanguage() {
    return currentLanguage;
  }

  /**
   * Obtiene la lista de idiomas soportados
   * @returns {string[]} Lista de códigos de idioma
   */
  function getSupportedLanguages() {
    return [...supportedLanguages];
  }

  /**
   * Inicializa el sistema de internacionalización
   */
  function init() {
    // Detectar idioma preferido del navegador
    const browserLang = (navigator.language || navigator.userLanguage || 'en').split('-')[0];
    
    // Intentar cargar idioma guardado o detectar del navegador
    const savedLang = localStorage.getItem('preferredLanguage');
    const langToUse = savedLang || (translations[browserLang] ? browserLang : 'en');
    
    setLanguage(langToUse);
    
    // Escuchar cambios en las preferencias de idioma del sistema
    window.addEventListener('languagechange', () => {
      const newLang = (navigator.language || 'en').split('-')[0];
      if (translations[newLang] && !localStorage.getItem('preferredLanguage')) {
        setLanguage(newLang);
      }
    });
  }

  // Inicializar al cargar
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // API pública
  return {
    t,
    setLanguage,
    getCurrentLanguage,
    getSupportedLanguages,
    on: (event, callback) => window.addEventListener(event, (e) => callback(e.detail))
  };
})();

// Exportar para módulos
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  module.exports = i18n;
} else {
  window.i18n = i18n;
}
</script>

<style>
:root{
  --bg:#f7f9fc;
  --fg:#1c1c1e;
  --header-bg:#f2f2f2;
  --muted:#6b7280;
  --input-bg:#ffffff;
  --input-border:#d1d5db;
  --accent:#2979ff;
  --accent-soft:rgba(41,121,255,0.1);
  --button-bg:#ebf1ff;
  --button-border:#c3d4ff;
  --cell-even:#ffffff;
  --cell-odd:#f4f7ff;
  --error:#ff6b6b;
  --th-bg:#eef2ff;
  --th-height:40px;
  --row-height:28px;
  --font-main:'Segoe UI', Tahoma, sans-serif;
  --custom-font-size:12px;
}

body.dark{
  --bg:#141414;
  --fg:#EEEEEE;
  --header-bg:#222222;
  --muted:#aaa;
  --cell-even:#252525;
  --cell-odd:#202020;
  --accent:#2979ff;
  --input-border:#555;
  --input-bg:#2a2a2a;
  --button-bg:#333;
  --button-border:#555;
}

*{box-sizing:border-box; font-family:inherit;}
body{
  margin:0; 
  font-family:var(--font-main); 
  font-size:var(--custom-font-size, 14px);
  color:var(--fg);
  background:var(--bg); 
  -webkit-font-smoothing:antialiased;
}

.container{padding:12px;}
.row{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
.row.top-controls{justify-content:space-between;}
.sr-only{
  position:absolute;
  width:1px;
  height:1px;
  padding:0;
  margin:-1px;
  overflow:hidden;
  clip:rect(0,0,0,0);
  white-space:nowrap;
  border:0;
}
.url-control-group{
  display:flex;
  gap:8px;
  flex:0 1 420px;
  max-width:100%;
  align-items:center;
}
.url-input-wrapper{
  position:relative;
  flex:1 1 auto;
  max-width:420px;
  min-width:180px;
}
#urlIn{
  width:100%;
  padding-right:30px;
  box-sizing:border-box;
  min-width:0;
}
#urlClearBtn{position:absolute;right:8px;top:50%;transform:translateY(-50%);display:none;z-index:10;background:transparent;border:none;cursor:pointer;padding:0 4px;line-height:1;}

@media (max-width: 900px) {
  .url-control-group{
    flex:0 1 360px;
  }
  .url-input-wrapper{
    max-width:360px;
  }
}

@media (max-width: 600px) {
  .url-control-group{
    flex:0 1 300px;
  }
  .url-input-wrapper{
    max-width:300px;
  }
}
.filter-edit-row{align-items:center;margin-top:10px;gap:8px;}
.filter-global-wrapper{position:relative;width:300px;max-width:100%;}
.table-message{
  padding:20px;
  text-align:center;
  font-size:1.1em;
  border-radius:6px;
  margin:10px 0;
}
.table-message--error{
  color:#ff6b6b;
  border:1px solid #ff6b6b;
  background-color:rgba(255,107,107,0.1);
}

.history-search{
  margin-top:6px;
  display:flex;
  gap:8px;
  align-items:center;
}

.history-search input{
  flex:1;
  padding:6px 10px;
  border-radius:6px;
  border:1px solid var(--input-border);
  background:var(--input-bg);
  color:var(--fg);
}

.history-meta{
  font-size:12px;
  margin-top:4px;
}

input[type=text], textarea, select, button{
  font-family:var(--font-main);
  font-size:inherit;
}

textarea#jsonin{
  width:100%;
  min-height:120px;
  padding:10px 14px;
  border:1px solid var(--input-border);
  border-radius:6px;
  background:var(--input-bg);
  color:var(--fg);
  font-size:var(--custom-font-size, 12px);
  line-height:1.4;
  resize:vertical;
  box-shadow:0 2px 6px rgba(15, 15, 15, 0.05);
  transition:border-color .2s ease, box-shadow .2s ease;
}

@media (max-width: 768px) {
  textarea#jsonin {
    font-size: calc(var(--custom-font-size, 12px) - 1px);
    min-height: 90px;
    line-height: 1.3;
  }
}

/* Ajustes para pantallas pequeñas */
@media (max-width: 480px) {
  textarea#jsonin {
    font-size: calc(var(--custom-font-size, 12px) - 2px);
    min-height: 70px;
    line-height: 1.2;
    padding: 8px;
  }
}

textarea#jsonin.error{ 
  border-color:var(--error); 
  box-shadow:0 0 6px rgba(229,57,53,0.18); 
}

input[type=text]{
  padding:6px;
  border-radius:6px;
  border:1px solid var(--input-border);
  background:var(--input-bg);
  color:var(--fg);
}

select{
  padding:6px;
  border-radius:6px;
  border:1px solid var(--input-border);
  background:var(--input-bg);
  color:var(--fg);
}

button{
  padding:6px 10px;
  border-radius:6px;
  border:1px solid var(--button-border);
  background:var(--button-bg);
  color:var(--fg);
  cursor:pointer;
}
button:hover{
  opacity:0.9;
}
button:disabled{
  background:#f0f0f0;
  color:var(--muted);
  cursor:not-allowed;
}
body.dark button:disabled{
  background:#1a1a1a;
}

#drawer{
  position:fixed;
  top:0;
  width:360px;
  height:100vh;
  background:var(--bg);
  box-shadow:0 6px 24px rgba(0,0,0,0.12);
  transition:right .28s ease, opacity .28s ease;
  z-index:9999;
  padding:12px;
  overflow:auto;
  right:-380px;
  opacity:0;
  pointer-events:none;
  font-size:14px;
}
#drawer.open{
  right:0;
  opacity:1;
  pointer-events:auto;
}

.drawer-overlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.35);
  opacity:0;
  pointer-events:none;
  transition:opacity .25s ease;
  z-index:9998;
}

.drawer-overlay.visible{
  opacity:1;
  pointer-events:auto;
}

body.drawer-open{
  overflow:hidden;
}

.tab-bar{display:flex;gap:6px;margin-bottom:12px}
.tab-btn{
  flex:1;
  padding:10px;
  border-radius:8px;
  border:2px solid transparent;
  background:var(--button-bg);
  color:var(--fg);
  cursor:pointer;
  transition: all 0.2s ease;
  outline: none;
}

.tab-btn:hover {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(41, 121, 255, 0.2);
}

.tab-btn:focus-visible {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(41, 121, 255, 0.4);
}

.tab-btn.active{
  background:var(--accent);
  color:#fff;
  border-color: var(--accent);
}

/* Selector de fuentes con tamaño fijo */
#fontFamily {
  font-size: 14px !important; /* Tamaño fijo que no cambiará con el zoom */
  min-height: 32px;
  padding: 4px 8px;
  border: 1px solid var(--input-border);
  border-radius: 4px;
  background-color: var(--input-bg);
  color: var(--fg);
}

/* Asegurar que el dropdown también mantenga el tamaño */
#fontFamily option {
  font-size: 14px;
  padding: 4px 8px;
}

/* Estilos para el contenedor de tema */
.theme-toggle-container {
  background: var(--bg);
  border: 1px solid var(--input-border);
  border-radius: 8px;
  margin-bottom: 16px;
  overflow: hidden;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.theme-toggle-header {
  padding: 10px 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--bg-secondary);
}

.theme-toggle-title {
  font-weight: 500;
  color: var(--fg);
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.theme-toggle-buttons {
  display: flex;
  justify-content: center;
  gap: 12px;
  padding: 12px 16px;
  margin: 0;
}

/* Estilos para los botones de tema */
.theme-toggle-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid var(--button-border);
  background: var(--button-bg);
  color: var(--fg);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 13px;
}

.theme-toggle-btn:hover {
  background: var(--button-hover-bg);
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(var(--accent-rgb, 0, 102, 255), 0.2);
}

.theme-toggle-btn:active {
  transform: translateY(1px);
}

.tab-btn.active:after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  height: 3px;
  background: #fff;
  border-radius: 3px 3px 0 0;
}

#tableWrap{ 
  width:100%; 
  margin-top:10px; 
  box-shadow: 0 2px 6px rgba(0,0,0,0.12);
  border-radius:8px; 
  border:1px solid var(--input-border); 
  background:transparent; 
  min-height:200px; 
  height: calc(100vh - 200px); /* Ocupar el espacio disponible, con mínimo 200px */
  max-height: 80vh; /* Máximo 80% de la ventana para evitar problemas en pantallas pequeñas */
  overflow:auto;
  overflow-y: scroll;
}

table{border-collapse:collapse;width:100%;table-layout:fixed;}
th, td{
  padding: calc(var(--custom-font-size, 14px) * 0.4) calc(var(--custom-font-size, 14px) * 0.57);
  border:1px solid var(--input-border);
  white-space:nowrap;
  font-family:var(--font-main, monospace);
  font-size:var(--custom-font-size, 14px);
}

th[data-col] {
  cursor: pointer;
  user-select: none;
}

tbody tr{
  height:var(--row-height);
}

td.editable-cell{
  background: rgba(41, 121, 255, 0.12);
  box-shadow: inset 0 0 0 1px rgba(41, 121, 255, 0.3);
  transition: background 0.2s ease, box-shadow 0.2s ease;
}

body.dark td.editable-cell{
  background: rgba(100, 181, 246, 0.25);
  box-shadow: inset 0 0 0 1px rgba(144, 202, 249, 0.35);
}

td.editable-cell:focus { 
  outline: 2px solid rgba(41, 121, 255, 0.45);
  box-shadow: inset 0 0 0 2px rgba(41, 121, 255, 0.45);
  animation: editablePulse 1.2s ease-in-out infinite alternate;
}

@keyframes editablePulse {
  from {
    background: rgba(41, 121, 255, 0.16);
  }
  to {
    background: rgba(41, 121, 255, 0.25);
  }
}

.edit-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.edit-badge {
  display: none;
  padding: 6px 12px;
  border-radius: 999px;
  background: rgba(255, 193, 7, 0.18);
  color: rgba(130, 83, 0, 0.95);
  font-weight: 600;
  border: 1px solid rgba(255, 193, 7, 0.4);
  box-shadow: 0 2px 6px rgba(255, 193, 7, 0.22);
  gap: 6px;
  align-items: center;
  animation: badgePulse 1.8s ease-in-out infinite;
}

.edit-badge .edit-count {
  font-size: 12px;
  font-weight: 500;
  color: rgba(130, 83, 0, 0.8);
  margin-left: 4px;
}

body.dark .edit-badge .edit-count {
  color: rgba(255, 235, 180, 0.85);
}

body.dark .edit-badge {
  background: rgba(255, 214, 102, 0.18);
  color: rgba(255, 235, 180, 0.95);
  border-color: rgba(255, 214, 102, 0.5);
  box-shadow: 0 2px 6px rgba(255, 214, 102, 0.35);
}

@keyframes badgePulse {
  from { transform: translateY(0); opacity: 0.9; }
  to { transform: translateY(3px); opacity: 1; }
}

body.edit-mode-active .edit-badge {
  display: inline-flex;
}
thead th{
  height:var(--th-height); 
  background:var(--header-bg); 
  position:sticky; 
  top:0; 
  z-index:4;
  color:var(--fg);
}
thead tr.filter-row th{ 
  top: calc(var(--th-height)); 
  background:var(--header-bg); 
  z-index:5;
} 

tbody tr:nth-child(even) td{background:var(--cell-even)}
tbody tr:nth-child(odd) td{background:var(--cell-odd)}

th.order-asc::after{ content:" ↑"; color:var(--accent); font-weight:bold }
th.order-desc::after{ content:" ↓"; color:var(--accent); font-weight:bold }

.filter-col-wrap { 
  position: relative; 
}

.filter-col { 
  width: 100%; 
  box-sizing: border-box; 
  padding: 4px 28px 4px 8px;
  border-radius: 4px;
  border: 1px solid var(--input-border);
}

.clear-btn {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  cursor: pointer;
  color: #ff0000;
  font-size: 16px;
  padding: 2px 4px;
  font-weight: bold;
  transition: all 0.2s ease;
  z-index: 10;
  display: none;
}

.url-input-wrapper .clear-btn { right: 6px !important; }
.filter-global-wrapper .clear-btn { right: 8px; }

.filter-global {
  width: 100%;
  padding: 8px 36px 8px 12px;
  border-radius: 6px;
  border: 1px solid var(--input-border);
  background: var(--input-bg);
  color: var(--fg);
}

.clear-btn:hover {
  color: #cc0000;
  transform: translateY(-50%) scale(1.1);
}

.clear-btn:focus {
  outline: 2px solid rgba(255, 0, 0, 0.3);
  border-radius: 50%;
}

.filter-col-wrap .clear-btn,
#filterEditRow .clear-btn,
#urlClearBtn,
#filterGlobalClearBtn {
  color: #ff0000 !important;
  font-weight: bold;
  text-shadow: 0 0 1px rgba(0,0,0,0.2);
}

.filter-col-wrap .clear-btn:hover,
#filterEditRow .clear-btn:hover,
#urlClearBtn:hover,
#filterGlobalClearBtn:hover {
  color: #cc0000 !important;
  transform: translateY(-50%) scale(1.15);
}

#urlClearBtn {
  right: 8px !important;
  color: #e53935 !important;
}

td.editable-cell:focus { 
  outline: 2px solid rgba(41, 121, 255, 0.16); 
}
@keyframes filterBlink {
  0% {
    background-color: var(--cell-even);
    opacity: 1;
  }
  50% {
    background-color: rgba(255, 235, 59, 0.3);
    opacity: 1;
  }
  100% {
    background-color: var(--cell-even);
    opacity: 1;
  }
}

@keyframes filterBlinkOdd {
  0% {
    background-color: var(--cell-odd);
    opacity: 1;
  }
  50% {
    background-color: rgba(255, 235, 59, 0.3);
    opacity: 1;
  }
  100% {
    background-color: var(--cell-odd);
    opacity: 1;
  }
}

@keyframes smoothBlink {
  0% {
    background-color: var(--blink-origin, transparent);
  }
  50% {
    background-color: rgba(255, 235, 59, 0.3);
  }
  100% {
    background-color: var(--blink-origin, transparent);
  }
}

.blink-cell {
  animation: smoothBlink 1s ease-in-out 1 forwards;
}

mark.highlight {
  background-color: rgba(255, 235, 59, 0.6);
  color: #000;
  padding: 0;
  border-radius: 2px;
}

.dark mark.highlight {
  background-color: rgba(255, 221, 87, 0.8);
  color: #000;
  padding: 0;
}

/* Reglas antiguas removidas para simplicidad */

#rawDisplay{
  display:none;
  width:100%;
  min-height:160px;
  padding:10px;
  border:2px solid var(--input-border);
  border-radius:6px;
  white-space:pre;
  overflow:auto;
  background:var(--input-bg);
  color:var(--fg);
}

.hide-without-data{
  display:none;
}
.show-with-data{
  display:flex;
}
@media (max-width:720px){
  #drawer{width:100vw}
  thead tr.filter-row th{ top: calc(var(--th-height) + 2px) }
}

.custom-panel {
  gap: 12px;
  padding: 20px;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  max-width: 320px;
  margin: 0 auto;
  color: var(--fg);
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

.dark .custom-panel {
  background: var(--input-bg);
  border-color: var(--input-border);
}

.dark .setting-row input[type="color"] {
  background: #333;
  border-color: #555;
}


.preset-dropdown,
.language-presets,
.history-presets,
.theme-presets {
  margin-top: 12px;
  padding: 12px;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
  overflow: visible;
}
.preset-dropdown-title,
.language-presets-title,
.history-presets-title,
.theme-presets-title {
  font-weight: 700;
  font-size: 14px;
  color: var(--fg);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

.preset-dropdown-trigger {
  position: relative;
  width: 100%;
}

.preset-dropdown-toggle,
.language-presets-toggle,
.history-presets-toggle,
.theme-presets-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 6px; /* Cambiado a 6px en todos los lados */
  border-radius: 6px;
  border: 1px solid var(--input-border);
  background: var(--bg);
  color: var(--fg);
  cursor: pointer;
  width: 100%;
  min-height: 40px;
}

.preset-dropdown-toggle:hover,
.preset-dropdown-toggle:focus,
.language-presets-toggle:hover,
.language-presets-toggle:focus,
.history-presets-toggle:hover,
.history-presets-toggle:focus,
.theme-presets-toggle:hover,
.theme-presets-toggle:focus {
  border-color: var(--accent);
  outline: none;
}

.preset-dropdown-selected,
.language-presets-selected,
.history-presets-selected,
.theme-presets-selected {
  flex: 1;
  font-size: 13px;
  color: var(--muted);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

.preset-dropdown-caret,
.language-presets-caret,
.history-presets-caret,
.theme-presets-caret {
  font-size: 16px;
}

.preset-dropdown-menu,
.language-presets-dropdown,
.history-presets-dropdown,
.theme-presets-dropdown {
  position: absolute;
  top: calc(100% + 6px);
  left: 0;
  right: 0;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  box-shadow: 0 10px 24px rgba(0,0,0,0.12);
  max-height: 220px;
  overflow-y: auto;
  width: 100%;
  z-index: 200;
  transform: translateZ(0);
}

.preset-dropdown-menu[hidden],
.language-presets-dropdown[hidden],
.history-presets-dropdown[hidden],
.theme-presets-dropdown[hidden] {
  display: none !important;
}

.preset-dropdown-list,
.language-presets-list,
.history-presets-list,
.theme-presets-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px;
}

.preset-dropdown-item,
.language-preset-item,
.history-preset-item,
.theme-preset-item,
.preset-dropdown-item *,
.language-preset-item *,
.history-preset-item *,
.theme-preset-item * {
  font-weight: 400 !important; /* Forzar peso normal en todos los elementos */
}

.preset-dropdown-item,
.language-preset-item,
.history-preset-item,
.theme-preset-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 6px;
  padding: 6px 8px;
  border-radius: 6px;
  transition: background 0.15s ease, border-color 0.15s ease;
  border: 1px solid transparent;
  background: #fff;
}

.preset-dropdown-item:hover,
.language-preset-item:hover,
.history-preset-item:hover,
.theme-preset-item:hover {
  background: rgba(var(--accent-rgb, 0, 102, 255), 0.16);
  border-color: rgba(var(--accent-rgb, 0, 102, 255), 0.25);
}

.preset-dropdown-item[aria-selected="true"],
.language-preset-item[aria-selected="true"],
.history-preset-item[aria-selected="true"],
.theme-preset-item[aria-selected="true"] {
  background: #fff;
  border-color: transparent;
}

.preset-dropdown-item[aria-selected="true"]:hover,
.language-preset-item[aria-selected="true"]:hover,
.history-preset-item[aria-selected="true"]:hover,
.theme-preset-item[aria-selected="true"]:hover {
  background: rgba(var(--accent-rgb, 0, 102, 255), 0.16);
  border-color: rgba(var(--accent-rgb, 0, 102, 255), 0.25);
}

.preset-dropdown-name,
.language-preset-name,
.history-preset-name,
.preset-name-btn {
  flex: 1;
  text-align: left;
  background: transparent;
  color: var(--fg);
  border: none;
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
}

.font-selector,
#fontFamily {
  width: 100px;
}

.dark .font-selector,
.dark #fontFamily {
  background: #333;
  border-color: #555;
  color: #fff;
}

.custom-panel h2 {
  font-size: 1.2em;
  margin: 0 0 16px 0;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--input-border);
  color: var(--fg);
  text-align: center;
}

.setting-container {
  width: 100%;
  max-width: 300px;
  margin: 0 auto;
}

.setting-row {
  display: flex;
  justify-content: normal;
  align-items: center;
  padding: 6px 0;
  width: 100%;
  margin: 0 auto;
}

.setting-row label {
  width: 140px;
  font-weight: 500;
  font-size: 13px;
  color: var(--fg);
  text-align: right;
  margin-right: 6px;
  cursor: default; 
  user-select: none;
  pointer-events: none;
  padding: 5px 0;
}

.setting-row input[type="color"] {
  width: 48px;
  height: 22px;
  border: 1px solid var(--input-border);
  border-radius: 6px;
  background: transparent;
  cursor: pointer;
  padding: 0;
  box-sizing: border-box;
  -webkit-appearance: none;
  appearance: none;
}

.setting-row input[type="color"]::-webkit-color-swatch,
.setting-row input[type="color"]::-webkit-color-swatch-wrapper {
  border: none;
  border-radius: 4px;
  padding: 0;
}

.setting-row input[type="color"]::-moz-color-swatch {
  border: none;
  border-radius: 4px;
}

.setting-row input[type="color"]:hover {
  transform: scale(1.01);
}

.setting-row input[type="color"]:active {
  transform: scale(0.98);
}


.theme-presets {
  margin-top: 12px;
  padding: 12px;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}

.theme-presets-title {
  font-weight: 600;
  color: var(--fg);
  text-align: center;
}

.theme-presets-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 10px 16px;
  border-radius: 6px;
  border: 1px solid var(--input-border);
  background: var(--bg);
  color: var(--fg);
  cursor: pointer;
  width: 100%;
  min-height: 40px;
}

.theme-presets-toggle:hover,
.theme-presets-toggle:focus {
  border-color: var(--accent);
  outline: none;
}

.theme-presets-selected {
  flex: 1;
  font-size: 13px;
  color: var(--muted);
  text-align: left;
}

.theme-presets-caret {
  font-size: 16px;
}

.theme-presets-dropdown {
  position: absolute;
  top: calc(100% + 6px);
  left: 0;
  right: 0;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--bg);
  box-shadow: 0 12px 28px rgba(0,0,0,0.18);
  max-height: 220px;
  overflow-y: auto;
  width: 100%;
  z-index: 200;
}

.language-presets-dropdown[hidden],
.history-presets-dropdown[hidden],
.theme-presets-dropdown[hidden] {
  display: none !important;
}

.theme-presets-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px;
}

.theme-presets-empty {
  font-size: 13px;
  color: var(--muted);
  padding: 8px;
}

.theme-presets-actions {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-top: 8px;
}

.theme-action-btn {
  flex: 1;
  padding: 10px 12px;
  border-radius: 6px;
  border: 1px solid var(--button-border);
  background: var(--button-bg);
  color: var(--fg);
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
  max-width: 180px;
}

.theme-action-btn:hover,
.theme-action-btn:focus {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
  outline: none;
}

.theme-presets-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px;
}

.theme-presets-empty {
  font-size: 13px;
  color: var(--muted);
  padding: 8px;
}

.theme-preset-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 6px;
  padding: 6px 8px;
  border-radius: 6px;
  transition: background 0.2s ease;
}

.theme-preset-item:hover {
  background: rgba(var(--accent-rgb, 0, 102, 255), 0.12);
}

.preset-name-btn {
  flex: 1;
  text-align: left;
  background: transparent;
  color: var(--fg);
  border: none;
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
}

.preset-inline-actions {
  display: flex;
  gap: 4px;
}

.preset-inline-btn {
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  border: 1px solid var(--button-border);
  background: var(--button-bg);
  color: var(--fg);
  cursor: pointer;
  transition: background 0.2s ease, transform 0.15s ease;
  font-size: 15px;
}

.preset-inline-btn:hover {
  transform: translateY(-1px);
}

.preset-inline-rename:hover {
  background: rgba(76, 175, 80, 0.2);
  border-color: rgba(76, 175, 80, 0.4);
}

.preset-inline-delete:hover {
  background: rgba(244, 67, 54, 0.2);
  border-color: rgba(244, 67, 54, 0.4);
}

.theme-presets-meta {
  font-size: 12px;
  color: var(--muted);
}

.language-presets {
  margin-top: 12px;
  padding: 12px;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}

.language-presets-title {
  font-weight: 600;
  color: var(--fg);
  text-align: center;
}

.language-presets-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 10px 16px;
  border-radius: 6px;
  border: 1px solid var(--input-border);
  background: var(--bg);
  color: var(--fg);
  cursor: pointer;
  width: 100%;
  min-height: 40px;
}

.language-presets-toggle:hover,
.language-presets-toggle:focus {
  border-color: var(--accent);
  outline: none;
}

.language-presets-selected {
  flex: 1;
  font-size: 13px;
  color: var(--muted);
  text-align: left;
}

.language-presets-caret {
  font-size: 16px;
}

.language-presets-dropdown {
  position: absolute;
  top: calc(100% + 6px);
  left: 0;
  right: 0;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  box-shadow: 0 10px 24px rgba(0,0,0,0.12);
  max-height: 220px;
  overflow-y: auto;
  width: 100%;
  z-index: 200;
}

.language-presets-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px;
}

.history-preset-item,
.history-preset-item * {
  font-weight: 400 !important; /* Forzar peso normal en todos los elementos */
}

.history-preset-item {
  display: flex;
  flex-direction: column;
  padding: 8px 12px;
  cursor: pointer;
  transition: background-color 0.2s;
  position: relative;
}

.history-preset-item .history-preset-name {
  width: 100%;
}

.history-preset-item .history-inline-actions {
  position: absolute;
  right: 8px;
  top: 8px;
}

.history-preset-item:hover {
  background: rgba(var(--accent-rgb, 0, 102, 255), 0.12);
}

.history-preset-name {
  flex: 1;
  text-align: left;
  background: transparent;
  color: var(--fg);
  border: none;
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
}

.history-inline-actions {
  display: flex;
  gap: 4px;
}

.history-inline-btn {
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  border: 1px solid var(--button-border);
  background: var(--button-bg);
  color: var(--fg);
  cursor: pointer;
  transition: background 0.2s ease, transform 0.15s ease;
  font-size: 15px;
}

.history-inline-btn:hover {
  transform: translateY(-1px);
}

.history-inline-rename:hover {
  background: rgba(76, 175, 80, 0.2);
  border-color: rgba(76, 175, 80, 0.4);
}

.history-inline-delete:hover {
  background: rgba(244, 67, 54, 0.2);
  border-color: rgba(244, 67, 54, 0.4);
}


.reset-container {
  margin: 0 auto;
  padding: 6px 0 0;
  display: flex;
  gap: 12px;
  justify-content: center;
  width: 100%;
  max-width: 320px;
}

.setting-row input[type="color"]:hover {
  transform: scale(1.01);
}

.reset-btn {
  padding: 10px 16px;
  border-radius: 6px;
  background: var(--button-bg);
  border: 1px solid var(--button-border);
  color: var(--fg);
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
  flex: 1;
  max-width: 220px;
}

.reset-btn:hover {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

#customPanel .form-row {
  margin: 0;
  padding: 0;
}

#fontFamily {
  width: 100px;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--input-border);
  background: var(--bg);
  color: var(--fg);
  font-size: 12px;
  cursor: pointer;
  transition: border-color 0.2s ease;
}

#fontFamily:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(41, 121, 255, 0.1);
}

#fontFamily {
  position: relative;
  z-index: 1001;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid var(--input-border);
  background: var(--input-bg);
  color: var(--fg);
  min-width: 100px;
  font-size: var(--custom-font-size, 12px);
}

#fontFamily option {
  position: relative;
  z-index: 1002;
  padding: 4px 8px;
}

select {
  -webkit-appearance: menulist;
  -moz-appearance: menulist;
  appearance: menulist;
}

html {
  overflow-y: scroll;
}
</style>
</head>
<body>
<div class="container">

  <div class="row top-controls" id="topControls">
    <div class="url-control-group" role="group" aria-label="Controles de URL" data-i18n-aria-label="urlControls">
      <div class="url-input-wrapper">
        <label for="urlIn" class="sr-only">Pegar URL</label>
        <input type="text" id="urlIn" placeholder="Pega URL aquí..." aria-label="Pegar URL" data-i18n-placeholder="urlPlaceholder" data-i18n-aria-label="urlPlaceholder" />
        <button id="urlClearBtn" class="clear-btn" title="Limpiar URL" aria-label="Limpiar URL" data-i18n-title="clearUrl" data-i18n-aria-label="clearUrl" style="right: 8px !important;">✕</button>
      </div>
      <button id="fetchBtn" aria-label="Cargar URL" title="Cargar URL" data-i18n="loadUrl" data-i18n-title="loadUrl" data-i18n-aria-label="loadUrl">Cargar URL</button>
    </div>
    <button id="configBtn" aria-label="Abrir configuración" title="Abrir configuración" class="config-btn" data-i18n-title="openConfiguration" data-i18n-aria-label="openConfiguration">⚙️</button>
  </div>

  <div class="row">
    <label for="jsonin" class="sr-only">Contenido JSON</label>
    <textarea id="jsonin" aria-label="Área JSON" placeholder="Pega o escribe JSON aquí" data-i18n-placeholder="jsonPlaceholder" data-i18n-aria-label="jsonPlaceholder"></textarea>
  </div>

  <div class="row">
    <button id="clearBtn" aria-label="Limpiar JSON" title="Limpiar JSON" data-i18n="clearJson" data-i18n-title="clearJson" data-i18n-aria-label="clearJson">Limpiar JSON</button>

    <label for="separatorSelect" style="display:flex;align-items:center;gap:6px">
      <span id="separatorLabel" data-i18n="separator">Separador:</span>
      <select id="separatorSelect" aria-label="Separador" data-i18n-aria-label="separator">
        <option value="	">Tab</option>
        <option value=",">,</option>
        <option value=";">;</option>
      </select>
    </label>

    <label for="downloadSelect" class="sr-only" data-i18n="download">Descargar</label>
    <select id="downloadSelect" aria-label="Descargar" disabled data-i18n-aria-label="download">
      <option value="" id="downloadOption" data-i18n="download">Descargar...</option>
      <option value="csv">CSV</option>
      <option value="xlsx">XLSX</option>
      <option value="txt">TXT</option>
    </select>

    <button id="toggleRawBtn" disabled aria-label="Mostrar raw" title="Mostrar/ocultar JSON raw" data-i18n-title="toggleRaw" data-i18n-aria-label="toggleRaw">Mostrar Raw</button>
    <button id="copyBtn" disabled aria-label="Copiar tabla" title="Copiar tabla al portapapeles" data-i18n="copyTable" data-i18n-title="copyTable" data-i18n-aria-label="copyTable">Copiar tabla</button>
  </div>

  <div class="row hide-without-data filter-edit-row" id="filterEditRow">
    <div class="filter-global-wrapper">
      <label for="filterGlobal" class="sr-only">Filtro global</label>
      <input type="text" id="filterGlobal" class="filter-global" placeholder="Filtro global..." autocomplete="off" data-i18n-placeholder="globalFilter" data-i18n-aria-label="globalFilter" />
      <button id="filterGlobalClearBtn" class="clear-btn" title="Limpiar filtro global" aria-label="Limpiar filtro global" data-i18n-title="clearFilter" data-i18n-aria-label="clearFilter">✕</button>
    </div>
    <div class="edit-controls">
      <button id="editBtn" aria-label="Editar tabla" title="Habilitar/deshabilitar edición" disabled data-i18n-title="toggleEdit" data-i18n-aria-label="toggleEdit"><span id="editBtnText" data-i18n="edit">✏️</span></button>
      <div id="editModeBadge" class="edit-badge" role="status" aria-live="polite" aria-hidden="true" data-count="0">
        ✏️ <span data-i18n="editModeActive">Modo edición activo</span>
        <span id="editModeCount" class="edit-count">(0)</span>
      </div>
    </div>
  </div>

  <div id="tableWrap" aria-live="polite">
  </div>

  <div id="liveRegion" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <div style="margin-top:8px">
    <textarea id="rawDisplay" readonly aria-label="Raw CSV" data-i18n-aria-label="rawCsv"></textarea>
  </div>

  <!-- Mensaje flotante para copiado -->
  <div id="copyMessage" class="copy-message" data-i18n="tableCopied" style="display: none; position: fixed; background: rgba(0, 0, 0, 0.8); color: white; padding: 10px 20px; border-radius: 8px; z-index: 10000; font-size: 14px; pointer-events: none;">Tabla copiada al portapapeles</div>
</div>
</div>

<!-- Overlay del drawer - Se hace visible mediante JavaScript -->
<div id="drawerOverlay" class="drawer-overlay" aria-hidden="true"></div>

<div id="drawer" role="dialog" aria-label="Configuración" style="position:fixed; padding-top:16px;">
  <button id="drawerCloseBtn" class="tab-btn" aria-label="Cerrar configuración" title="Cerrar configuración" style="position:absolute;top:10px;left:10px;width:36px;height:36px;font-size:22px;z-index:10001;display:flex;align-items:center;justify-content:center;line-height:36px;" data-i18n-title="closeConfiguration" data-i18n-aria-label="closeConfiguration">✕</button>
  
  <div class="tab-bar" style="margin-top: 40px;">
    <button class="tab-btn active" id="tabConfig" aria-label="Configuración" aria-selected="true" role="tab" data-i18n="configuration" data-i18n-aria-label="configuration" style="font-size: 15px;">
      <span id="tabConfigText" data-i18n="configuration">Configuración</span>
    </button>
    <button class="tab-btn" id="tabCustom" aria-label="Tema personalizado" aria-selected="false" role="tab" data-i18n="customTheme" data-i18n-aria-label="customTheme" style="font-size: 15px;">
      <span id="tabCustomText" data-i18n="customTheme">Tema personalizado</span>
    </button>
  </div>

  <div id="configContent" class="active">

    <div class="theme-toggle-container">
      <div class="theme-toggle-buttons">
        <button id="themeLight" class="theme-toggle-btn" aria-label="Cambiar a modo claro" title="Modo claro" data-i18n-title="lightMode" data-i18n-aria-label="lightMode">
          <span data-i18n="lightMode">Modo claro</span> ☀️
        </button>
        <button id="themeDark" class="theme-toggle-btn" aria-label="Cambiar a modo oscuro" title="Modo oscuro" data-i18n-title="darkMode" data-i18n-aria-label="darkMode">
          <span data-i18n="darkMode">Modo oscuro</span> 🌙
        </button>
      </div>
    </div>

    <div class="preset-dropdown" aria-label="Lenguaje" data-i18n-aria-label="language">
      <span id="languageLabel" class="preset-dropdown-title" data-i18n="language">Idioma</span>
      <div class="preset-dropdown-trigger">
        <button id="languageToggle" class="preset-dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="languageSelected">
          <span id="languageSelected" class="preset-dropdown-selected" data-i18n="selectLanguageOption">-- Seleccionar idioma --</span>
          <span class="preset-dropdown-caret" aria-hidden="true">▾</span>
        </button>
        <div id="languageDropdown" class="preset-dropdown-menu" role="listbox" hidden>
          <div id="languageList" class="preset-dropdown-list"></div>
        </div>
      </div>
    </div>

    <div class="preset-dropdown" aria-label="Historial JSON" data-i18n-aria-label="jsonHistory">
      <span id="historyLabel" class="preset-dropdown-title" data-i18n="jsonHistory">Historial JSON</span>
      <div class="preset-dropdown-trigger">
        <button id="jsonHistoryToggle" class="preset-dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="jsonHistorySelected">
          <span id="jsonHistorySelected" class="preset-dropdown-selected" data-i18n="selectJsonOption">-- Seleccionar JSON --</span>
          <span class="preset-dropdown-caret" aria-hidden="true">▾</span>
        </button>
        <div id="jsonHistoryDropdown" class="preset-dropdown-menu" role="listbox" aria-labelledby="historyLabel jsonHistorySelected" hidden>
          <div id="jsonHistoryList" class="preset-dropdown-list"></div>
        </div>
      </div>
      <div class="history-search">
        <label for="historySearchInput" class="sr-only">Buscar historial</label>
        <input type="text" id="historySearchInput" placeholder="Buscar en historial..." autocomplete="off" data-i18n-placeholder="historySearchPlaceholder" />
      </div>
    </div>

    <div style="margin-top:12px; opacity: 0.6;" title="Función deshabilitada">
      <button id="mobileSwitchBtn" aria-label="Cambio entre vista web y móvil deshabilitado" title="Cambio entre vista web y móvil deshabilitado" disabled data-i18n="webMobile" data-i18n-title="webMobile" data-i18n-aria-label="webMobile">
        <span id="mobileSwitchText">Web / Móvil (deshabilitado)</span>
      </button>
    </div>
  </div>

  <div id="customPanel" class="custom-panel" style="display:none;">
    <h2 id="customThemeTitle" data-i18n="customizeTheme" style="font-size: 14px; margin-bottom: 16px; font-weight: 700;">Personalizar tema</h2>

    <div class="setting-container">
      <div class="setting-row">
        <label id="bgColorLabel" data-i18n="background" for="bgColor">Fondo</label>
        <input type="color" id="bgColor" value="#ffffff">
      </div>

      <div class="setting-row">
        <label id="textColorLabel" data-i18n="text" for="textColor">Texto</label>
        <input type="color" id="textColor" value="#000000">
      </div>

      <div class="setting-row">
        <label id="fontSizeLabel" data-i18n="fontSize" for="fontSize">Tamaño de fuente</label>
        <input type="number" id="fontSize" min="5" max="30" step="1" value="14" aria-label="Tamaño de fuente" data-i18n-aria-label="fontSize">
      </div>

      <div class="setting-row">
        <label id="headerColorLabel" data-i18n="headerCells" for="headerColor">Encabezados</label>
        <input type="color" id="headerColor" value="#f2f2f2">
      </div>

      <div class="setting-row">
        <label id="cellOddLabel" data-i18n="oddCells" for="cellOdd">Celdas impares</label>
        <input type="color" id="cellOdd" value="#f0f0f0">
      </div>

      <div class="setting-row">
        <label id="cellEvenLabel" data-i18n="evenCells" for="cellEven">Celdas pares</label>
        <input type="color" id="cellEven" value="#ffffff">
      </div>

      <div class="setting-row">
        <label id="fontFamilyLabel" data-i18n="typography" for="fontFamily">Tipografía</label>
        <select id="fontFamily" class="font-selector">
          <option value="'Segoe UI', Tahoma, sans-serif">Segoe UI</option>
          <option value="'Roboto', Arial, sans-serif">Roboto</option>
          <option value="'Open Sans', Arial, sans-serif">Open Sans</option>
          <option value="'Helvetica Neue', Arial, sans-serif">Helvetica</option>
          <option value="'Times New Roman', Times, serif">Times New Roman</option>
          <option value="'Courier New', Courier, monospace">Courier New</option>
          <option value="'Georgia', serif">Georgia</option>
        </select>
      </div>
    </div>

    <div class="preset-dropdown" aria-label="Temas guardados" data-i18n-aria-label="themePresets">
      <span class="preset-dropdown-title" data-i18n="themePresets">Temas guardados</span>
      <div class="preset-dropdown-trigger">
        <button id="themePresetToggle" class="preset-dropdown-toggle" type="button" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="themePresetSelected">
          <span id="themePresetSelected" class="preset-dropdown-selected" data-i18n="themePresetPlaceholder">-- Seleccionar tema --</span>
          <span class="preset-dropdown-caret" aria-hidden="true">▾</span>
        </button>
        <div id="themePresetDropdown" class="preset-dropdown-menu" role="listbox" aria-labelledby="themePresetSelected" hidden>
          <div id="themePresetList" class="preset-dropdown-list"></div>
        </div>
      </div>
      <div class="theme-presets-actions">
        <button id="customSaveBtn" class="theme-action-btn" aria-label="Guardar tema" title="Guardar tema" data-i18n="saveTheme" data-i18n-title="saveTheme" data-i18n-aria-label="saveTheme">
          <span id="customSaveText" data-i18n="saveTheme">Guardar tema</span>
        </button>
        <button id="customDefaultBtn" class="theme-action-btn" aria-label="Restablecer valores predeterminados" title="Restablecer valores predeterminados" data-i18n="default" data-i18n-title="default" data-i18n-aria-label="default">
          <span id="customDefaultText" data-i18n="default">Restablecer valores predeterminados</span>
        </button>
      </div>
    </div>
  </div>
</div>

<script>
// Configuración de seguridad
const securityConfig = {
  // Dominios permitidos para fetch
  allowedDomains: [
    'api.example.com',
    'data.example.org'
  ],
  
  // Configuración de CSP
  csp: {
    reportOnly: window.location.hostname === 'localhost',
    reportUri: '/csp-violation-report-endpoint'
  },
  
  // Configuración de cabeceras de seguridad (deben configurarse en el servidor)
  securityHeaders: {
    'Cross-Origin-Opener-Policy': 'same-origin',
    'Cross-Origin-Resource-Policy': 'same-site',
    'Cross-Origin-Embedder-Policy': 'require-corp'
  }
};

// Inicializar seguridad - Configuración mínima para desarrollo
if (typeof Security !== 'undefined') {
  const extendedDomains = [...securityConfig.allowedDomains];
  if (['localhost', '127.0.0.1'].includes(window.location.hostname)) {
    extendedDomains.push('jsonplaceholder.typicode.com');
  }

  Security.ALLOWED_DOMAINS = extendedDomains;

  if (Security.CSP_CONFIG && Array.isArray(Security.CSP_CONFIG.connectSrc)) {
    Security.CSP_CONFIG.connectSrc = ["'self'", ...extendedDomains];
  }

  if (securityConfig.csp?.reportUri) {
    Security.CSP_CONFIG.reportUri = securityConfig.csp.reportUri;
  }

  console.warn('ADVERTENCIA: Para una configuración de seguridad óptima, configura los siguientes encabezados HTTP en tu servidor:');

  let cspHeader = "default-src 'self'";
  if (typeof Security.getCSPHeader === 'function') {
    cspHeader = Security.getCSPHeader(false);
    if (securityConfig.csp?.reportOnly) {
      console.log('Content-Security-Policy-Report-Only:', Security.getCSPHeader(true));
    }
  }
  console.log('Content-Security-Policy:', cspHeader);
  console.log('X-Frame-Options: DENY');
  console.log('X-Content-Type-Options: nosniff');
  console.log('X-XSS-Protection: 1; mode=block');
  console.log('Referrer-Policy: strict-origin-when-cross-origin');
}

// Objeto de traducciones completo
const translations = {
  es: {
    // Interfaz principal
    'appTitle': 'JSON a Tabla',
    'loadUrl': 'Cargar URL',
    
    // Modo gigante
    'enableGiantMode': 'Activar modo gigante (mejor rendimiento para tablas grandes)',
    'disableGiantMode': 'Desactivar modo gigante',
    'giantModeEnabled': 'Modo gigante activado. Se mostrarán los datos en bloques para mejor rendimiento.',
    'giantModeDisabled': 'Modo gigante desactivado. Se mostrarán todos los datos a la vez.',
    
    'edit': '✏️',
    'save': '💾',
    'cancel': 'Cancelar',
    'clearJson': 'Limpiar JSON',
    'showRaw': 'Ver JSON',
    'copyTable': 'Copiar tabla',
    'globalFilter': 'Filtrar...',
    'configuration': 'Configuración',
    'customTheme': 'Tema personalizado',
    'language': 'Idioma',
    'jsonHistory': 'Historial',
    'urlControls': 'Controles de URL',
    'clearUrl': 'Limpiar URL',
    'toggleRaw': 'Mostrar/ocultar JSON raw',
    'rawCsv': 'CSV en crudo',
    'separator': 'Separador:',
    'download': 'Descargar',
    'fontSize': 'Tamaño de fuente',
    'selectJsonOption': '-- Seleccionar JSON --',
    'languageEnglishDefault': 'Inglés',
    'languageSpanish': 'Español',
    'selectLanguageOption': '-- Seleccionar idioma --',
    'themePresetPlaceholder': '-- Seleccionar tema --',
    'selectJson': '-- Seleccionar --',
    'load': 'Cargar',
    'rename': 'Renombrar',
    'delete': 'Eliminar',
    'historySearchPlaceholder': 'Buscar en historial...',
    'webMobile': 'Vista móvil',
    'customizeTheme': 'Personalizar tema',
    'background': 'Fondo',
    'text': 'Texto',
    'headerCells': 'Encabezados',
    'typography': 'Tipografía',
    'evenCells': 'Filas pares',
    'oddCells': 'Filas impares',
    'default': 'Predeterminado',
    'editModeActive': 'Modo edición activo',
    'clearFilter': 'Limpiar filtro',
    'filterColumn': 'Filtrar columna',
    'noResults': 'No se encontraron resultados',
    'tableCopied': 'Tabla copiada al portapapeles',
    'sortColumnAsc': 'Ordenar columna ascendente',
    'sortColumnDesc': 'Ordenar columna descendente',
    'sortColumnDefault': 'Ordenar columna',
    'historyCount': '{current} de {total} (máx. {limit})',
    'historyNoMatches': 'No se encontraron coincidencias en el historial',
    'historySizeExceeded': 'El JSON es demasiado grande para guardar en el historial',
    'lastJsonSizeExceeded': 'El JSON es demasiado grande para guardarlo localmente',
    'loadJsonFromHistory': '¿Cargar JSON desde el historial?',
    'newName': 'Nuevo nombre',
    'selectItemToDelete': 'Selecciona un elemento para eliminar',
    'deleteFromHistory': '¿Eliminar del historial?',
    'resetThemeConfirm': '¿Restablecer tema personalizado?',
    'loading': 'Cargando...',
    'urlPlaceholder': 'Pega URL aquí...',
    'jsonPlaceholder': 'Pega o escribe JSON aquí',
    'themePresets': 'Temas guardados',
    'noThemePresets': 'No hay temas guardados',
    'loadThemePreset': 'Cargar tema',
    'renameThemePreset': 'Renombrar tema',
    'deleteThemePreset': 'Eliminar tema',
    'saveTheme': 'Guardar tema',
    'toggleEdit': 'Habilitar/deshabilitar edición',
    'openConfiguration': 'Abrir configuración',
    'closeConfiguration': 'Cerrar configuración',
    'lightMode': 'Modo claro',
    'darkMode': 'Modo oscuro',
    'languageEnglishDefault': 'Inglés',
    'languageSpanish': 'Español'
  },
  en: {
    // Main interface
    'appTitle': 'JSON to Table',
    'loadUrl': 'Load URL',
    
    // Giant mode
    'enableGiantMode': 'Enable giant mode (better performance for large tables)',
    'disableGiantMode': 'Disable giant mode',
    'giantModeEnabled': 'Giant mode enabled. Data will be shown in chunks for better performance.',
    'giantModeDisabled': 'Giant mode disabled. All data will be shown at once.',
    
    'edit': '✏️',
    'save': '💾',
    'cancel': 'Cancel',
    'clearJson': 'Clear JSON',
    'showRaw': 'View JSON',
    'copyTable': 'Copy table',
    'globalFilter': 'Filter...',
    'configuration': 'Settings',
    'customTheme': 'Custom Theme',
    'language': 'Language',
    'jsonHistory': 'History',
    'urlControls': 'URL controls',
    'clearUrl': 'Clear URL',
    'toggleRaw': 'Show/Hide raw JSON',
    'rawCsv': 'Raw CSV',
    'separator': 'Separator:',
    'download': 'Download',
    'fontSize': 'Font size',
    'selectJsonOption': '-- Select JSON --',
    'languageEnglishDefault': 'English',
    'languageSpanish': 'Español',
    'selectLanguageOption': '-- Select language --',
    'themePresetPlaceholder': '-- Select theme --',
    'selectJson': '-- Select --',
    'load': 'Load',
    'rename': 'Rename',
    'delete': 'Delete',
    'historySearchPlaceholder': 'Search history...',
    'webMobile': 'Mobile view',
    'customizeTheme': 'Customize theme',
    'background': 'Background',
    'text': 'Text',
    'headerCells': 'Headers',
    'typography': 'Typography',
    'evenCells': 'Even rows',
    'oddCells': 'Odd rows',
    'default': 'Default',
    'editModeActive': 'Edit mode active',
    'clearFilter': 'Clear filter',
    'filterColumn': 'Filter column',
    'noResults': 'No results found',
    'tableCopied': 'Table copied to clipboard',
    'sortColumnAsc': 'Sort column ascending',
    'sortColumnDesc': 'Sort column descending',
    'sortColumnDefault': 'Sort column',
    'historyCount': '{current} of {total} (max {limit})',
    'historyNoMatches': 'No matches found in history',
    'historySizeExceeded': 'JSON is too large to save in history',
    'lastJsonSizeExceeded': 'JSON is too large to save locally',
    'loadJsonFromHistory': 'Load JSON from history?',
    'newName': 'New name',
    'selectItemToDelete': 'Select an item to delete',
    'deleteFromHistory': 'Delete from history?',
    'resetThemeConfirm': 'Reset custom theme?',
    'loading': 'Loading...',
    'urlPlaceholder': 'Paste URL here...',
    'jsonPlaceholder': 'Paste or type JSON here',
    'themePresets': 'Saved themes',
    'noThemePresets': 'No saved themes',
    'loadThemePreset': 'Load theme',
    'renameThemePreset': 'Rename theme',
    'deleteThemePreset': 'Delete theme',
    'saveTheme': 'Save theme',
    'toggleEdit': 'Enable/disable editing',
    'openConfiguration': 'Open settings',
    'closeConfiguration': 'Close settings',
    'lightMode': 'Light mode',
    'darkMode': 'Dark mode',
    'languageEnglishDefault': 'English',
    'languageSpanish': 'Spanish'
  }
};

// Función de traducción unificada
function t(key, params = {}) {
  const lang = state?.currentLanguage || 'es';
  
  // Obtener la traducción o la clave si no existe
  let text = translations[lang]?.[key] || 
             translations['en'][key] || 
             key;
  
  // Reemplazar parámetros si los hay
  if (Object.keys(params).length > 0) {
    text = Object.entries(params).reduce(
      (result, [param, value]) => 
        result.replace(new RegExp(`{{${param}}}`, 'g'), String(value)),
      text
    );
  }
  
  return text;
}

function verifyTranslations() {
  const missing = new Map();
  const languages = Object.keys(translations);

  const attributeSelectors = [
    '[data-i18n]',
    '[data-i18n-placeholder]',
    '[data-i18n-title]',
    '[data-i18n-aria-label]'
  ];

  attributeSelectors.forEach(selector => {
    document.querySelectorAll(selector).forEach(node => {
      const attrs = Array.from(node.attributes).filter(attr => attr.name.startsWith('data-i18n'));
      attrs.forEach(attr => {
        const key = attr.value;
        languages.forEach(lang => {
          if (!translations[lang] || translations[lang][key] === undefined) {
            if (!missing.has(key)) missing.set(key, new Set());
            missing.get(key).add(lang);
          }
        });
      });
    });
  });

  if (missing.size > 0) {
    console.warn('[i18n] Claves sin traducción:', Array.from(missing.entries()).map(([key, langs]) => ({ key, languages: Array.from(langs) })));
  }
}

// Configuración de internacionalización
const i18nConfig = {
  defaultLanguage: 'es',
  supportedLanguages: ['es', 'en'],
  
  // Función para cambiar de idioma
  changeLanguage: function(lang) {
    if (this.supportedLanguages.includes(lang)) {
      i18n.setLanguage(lang);
      
      // Actualizar la interfaz
      updateUITexts();
      
      // Guardar preferencia
      localStorage.setItem('preferredLanguage', lang);
      
      return true;
    }
    return false;
  },
  
  // Inicializar internacionalización
  init: function() {
    // Cargar idioma guardado o detectar del navegador
    const savedLang = localStorage.getItem('preferredLanguage');
    const browserLang = (navigator.language || 'en').split('-')[0];
    const langToUse = savedLang || (this.supportedLanguages.includes(browserLang) ? browserLang : this.defaultLanguage);
    
    this.changeLanguage(langToUse);
    
    // Escuchar cambios en las preferencias de idioma del sistema
    window.addEventListener('languagechange', () => {
      const newLang = (navigator.language || 'en').split('-')[0];
      if (this.supportedLanguages.includes(newLang) && !localStorage.getItem('preferredLanguage')) {
        this.changeLanguage(newLang);
      }
    });
  }
};

// Función de inicialización principal
async function initializeApp() {
  // Inicializar internacionalización
  if (typeof i18n !== 'undefined' && typeof i18nConfig !== 'undefined') {
    try {
      i18nConfig.init();
    } catch (e) {
      console.warn('Error al inicializar i18n:', e);
      // Establecer un idioma predeterminado si falla la inicialización
      state.currentLanguage = 'es';
    }
  } else {
    // Si i18n no está disponible, usar el idioma del navegador
    const browserLang = (navigator.language || 'es').split('-')[0];
    state.currentLanguage = ['es', 'en'].includes(browserLang) ? browserLang : 'es';
  }
  
  try {
    // Sincronizar con el idioma establecido por i18nConfig.init()
    const savedLang = (typeof localStorage !== 'undefined' && localStorage.getItem('preferredLanguage'))
      || state.currentLanguage
      || (typeof i18n !== 'undefined' && typeof i18n.getCurrentLanguage === 'function' ? i18n.getCurrentLanguage() : null)
      || 'es';
    state.currentLanguage = savedLang;
    if (el.languageSelect) el.languageSelect.value = savedLang;

    if (typeof changeLanguage === 'function') {
      changeLanguage(savedLang);
    } else if (typeof i18n !== 'undefined' && typeof i18n.setLanguage === 'function') {
      i18n.setLanguage(savedLang);
    }

    // Cargar tema
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      document.body.classList.add('dark');
    } else {
      document.body.classList.remove('dark');
    }

    // Cargar configuraciones adicionales
    loadCustomTheme();
    updateRowHeight();
    loadHistory();
    loadColumnFilters();

    // Cargar último JSON si existe
    const last = localStorage.getItem('lastJson');
    if (last && last.trim()) { 
      el.jsonin.value = last; 
      state.lastParsedFull = tryParseJson(last); 
      await parseJsonInput(false); 
    } else { 
      updateActionButtons(); 
    }

    // Actualizar estado de la interfaz
    updateFetchButtonState();

    // Configurar modo móvil
    const mobile = localStorage.getItem('mobileMode') === 'true';
    enableMobileMode(mobile);
    
    // Inicializar botones de limpieza
    initClearButtons();
    
    // Renderizar la tabla si hay datos
    if (state.currentRows && state.currentRows.length > 0) {
      renderTable();
    }
    
  } catch (error) {
    console.error('Error durante la inicialización:', error);
  }
}

// Función para manejar el evento de scroll y el renderizado virtual
function handleScroll() {
  if (state.isScrolling) return;
  
  state.isScrolling = true;
  requestAnimationFrame(() => {
    renderTable();
    state.isScrolling = false;
  });
}

// Función para inicializar el scroll infinito
function initInfiniteScroll() {
  if (el.tableWrap) {
    el.tableWrap.addEventListener('scroll', handleScroll, { passive: true });
  }
  
  // El modo de alto rendimiento ahora es automático basado en el tamaño de los datos
}

// Inicializar la aplicación cuando el DOM esté listo
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  initInfiniteScroll();
});

// Las traducciones ahora están en i18n.js

// Inicializar el estado
const state = {
  // Datos y filtrado
  data: [],
  filteredData: [],
  filters: {},
  filterCache: {},
  lastFilterSignature: null,
  
  // Ordenamiento
  sortColumn: null,
  sortDirection: 'asc',
  sortState: {},
  
  // Paginación
  currentPage: 1,
  rowsPerPage: 50,
  selectedRows: [],
  
  // Historial
  history: [],
  historyFilter: '',
  selectedHistoryIndex: null,
  
  // Edición
  editMode: false,
  editing: false,
  editedCells: new Set(),
  
  // Configuración
  language: 'es',
  selectedLanguage: null,
  theme: 'light',
  customTheme: null,
  mobileMode: window.innerWidth < 768,
  giantMode: false, // Modo gigante para conjuntos de datos muy grandes
  
  // Datos originales
  originalParsed: null,
  originalRows: [],
  currentRows: [],
  currentHeaders: [],
  
  // UI y renderizado
  lastJson: null,
  lastJsonSize: 0,
  virtualStart: 0,
  visibleCount: 0, // Número de filas visibles en el viewport
  chunkSize: 200, // Tamaño del chunk para renderizado por partes
  renderedChunks: new Set(), // Chunks ya renderizados
  isScrolling: false, // Flag para controlar el evento de scroll
  scrollDebounce: null, // Referencia al timeout del debounce del scroll
  lastRenderTime: 0, // Último tiempo de renderizado
  minRenderInterval: 100, // Tiempo mínimo entre renders (ms)
  rowHeight: 32, // Altura de cada fila en píxeles (se calcula dinámicamente)
  
  // Cache para filtros y ordenamiento
  cache: {
    filteredRows: null,
    filterSignature: null,
    sortedRows: null,
    sortSignature: null
  },

  // Temas personalizados
  themePresets: [],
  selectedThemePreset: ''
};

// Elementos del DOM
const el = {
  urlIn: document.getElementById('urlIn'),
  urlClearBtn: document.getElementById('urlClearBtn'),
  fetchBtn: document.getElementById('fetchBtn'),
  configBtn: document.getElementById('configBtn'),
  jsonin: document.getElementById('jsonin'),
  clearBtn: document.getElementById('clearBtn'),
  downloadSelect: document.getElementById('downloadSelect'),
  separatorSelect: document.getElementById('separatorSelect'),
  toggleRawBtn: document.getElementById('toggleRawBtn'),
  copyBtn: document.getElementById('copyBtn'),
  filterGlobal: document.getElementById('filterGlobal'),
  filterGlobalClearBtn: document.getElementById('filterGlobalClearBtn'),
  editBtn: document.getElementById('editBtn'),
  tableWrap: document.getElementById('tableWrap'),
  rawDisplay: document.getElementById('rawDisplay'),
  drawer: document.getElementById('drawer'),
  drawerOverlay: document.getElementById('drawerOverlay'),
  tabConfig: document.getElementById('tabConfig'),
  tabCustom: document.getElementById('tabCustom'),
  configContent: document.getElementById('configContent'),
  customPanel: document.getElementById('customPanel'),
  themeLight: document.getElementById('themeLight'),
  themeDark: document.getElementById('themeDark'),
  languageSelect: document.getElementById('languageSelect'),
  languageToggle: document.getElementById('languageToggle'),
  languageDropdown: document.getElementById('languageDropdown'),
  languageList: document.getElementById('languageList'),
  languageSelected: document.getElementById('languageSelected'),
  jsonHistoryToggle: document.getElementById('jsonHistoryToggle'),
  jsonHistoryDropdown: document.getElementById('jsonHistoryDropdown'),
  jsonHistoryList: document.getElementById('jsonHistoryList'),
  jsonHistorySelected: document.getElementById('jsonHistorySelected'),
  historySearchInput: document.getElementById('historySearchInput'),
  historyMeta: document.getElementById('historyMeta'),
  liveRegion: document.getElementById('liveRegion'),
  customSaveBtn: document.getElementById('customSaveBtn'),
  themePresetList: document.getElementById('themePresetList'),
  themePresetMeta: document.getElementById('themePresetMeta'),
  themePresetToggle: document.getElementById('themePresetToggle'),
  themePresetDropdown: document.getElementById('themePresetDropdown'),
  themePresetSelected: document.getElementById('themePresetSelected'),
  mobileSwitchBtn: document.getElementById('mobileSwitchBtn'),
  bgColor: document.getElementById('bgColor'),
  textColor: document.getElementById('textColor'),
  headerColor: document.getElementById('headerColor'),
  fontFamily: document.getElementById('fontFamily'),
  cellEven: document.getElementById('cellEven'),
  cellOdd: document.getElementById('cellOdd'),
  fontSize: document.getElementById('fontSize'),
  customDefaultBtn: document.getElementById('customDefaultBtn'),
  filterEditRow: document.getElementById('filterEditRow'),
  drawerCloseBtn: document.getElementById('drawerCloseBtn'),
  editBtnText: document.getElementById('editBtnText')
};

const storedPreferredLanguage = (() => {
  const hasWindow = typeof window !== 'undefined';
  const hasLocalStorage = hasWindow && typeof localStorage !== 'undefined';
  const saved = hasLocalStorage ? localStorage.getItem('preferredLanguage') : null;
  if (saved) return saved;
  if (typeof i18n !== 'undefined' && typeof i18n.getCurrentLanguage === 'function') {
    return i18n.getCurrentLanguage();
  }
  return null;
})();

// Estado ya inicializado arriba
Object.assign(state, {
  visibleCount: 0,
  filterDebounceMs: 200,
  lastParsedFull: null,
  currentLanguage: storedPreferredLanguage || 'es',
  cache: {
    filteredRows: null,
    filterSignature: '',
    headerKeys: null,
    dataVersion: 0
  }
});

const MAX_LAST_JSON_SIZE = 2_000_000;
const HISTORY_MAX_JSON_SIZE = 250_000;
const HISTORY_MAX_ENTRIES = 100;
const HISTORY_DISPLAY_LIMIT = 50;
const JSON_INDENT = 2;

// Función para actualizar la altura de fila basada en el tamaño de fuente
function updateRowHeight() {
  let fontSize = parseFloat(getComputedStyle(document.documentElement).fontSize) || 14;
  if(fontSize < 5) fontSize = 5; // Limitar tamaño mínimo a 5px
  state.rowHeight = Math.ceil(fontSize * 1.4); // Factor reducido para altura de fila
  document.documentElement.style.setProperty('--row-height', state.rowHeight + 'px');
}

let announceTimer = null;
let editedCellSet = new Set();

const validators = {
  isValidUrl(value){
    if(!value || typeof value !== 'string') return false;
    const trimmed = value.trim();
    if(trimmed.length === 0) return false;
    try{
      new URL(trimmed);
      return true;
    }catch(e){
      try{
        new URL(`https://${trimmed}`);
        return true;
      }catch(e2){
        return false;
      }
    }
  }
};

function normalizeUrl(value){
  if(!value) return '';
  try{
    return new URL(value).href;
  }catch(e){
    try{
      return new URL(`https://${value}`).href;
    }catch(e2){
      return value;
    }
  }
}

async function fetchWithFallback(url, rawValue){
  try{
    const res = await fetch(url);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return res;
  }catch(err){
    const hasProtocol = /^https?:\/\//i.test(rawValue || '');
    if(!hasProtocol){
      try{
        const fallbackUrl = `http://${rawValue}`;
        const res = await fetch(fallbackUrl);
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        return res;
      }catch(err2){
        throw err2;
      }
    }
    throw err;
  }
}

function resetUrlVisualState(){
  el.urlIn.style.borderColor = '';
  el.urlIn.style.boxShadow = '';

  if(el.urlIn.disabled){
    el.urlIn.style.opacity = '0.6';
    el.urlIn.style.cursor = 'not-allowed';
  } else {
    el.urlIn.style.opacity = '1';
    el.urlIn.style.cursor = 'text';
  }

  if(el.fetchBtn.disabled){
    el.fetchBtn.style.opacity = '0.6';
    el.fetchBtn.style.cursor = 'not-allowed';
  } else {
    el.fetchBtn.style.opacity = '1';
    el.fetchBtn.style.cursor = 'pointer';
  }
}

function isObj(x){ 
  return x && typeof x === 'object' && !Array.isArray(x); 
}

function flattenObject(obj, prefix='', out={}){
  if(Array.isArray(obj)){ 
    out[prefix.slice(0,-1)||'array']=JSON.stringify(obj); 
    return out; 
  }
  for(const k of Object.keys(obj||{})){
    const v = obj[k], key = prefix + k + '.';
    if(isObj(v)) {
      flattenObject(v, key, out);
    } else if(Array.isArray(v)) {
      out[key.slice(0,-1)] = JSON.stringify(v);
    } else {
            out[key.slice(0,-1)] = v;
    }
  }
  return out;
}

function unflattenObject(flat){
  const res = {};
  for(const flatKey of Object.keys(flat || {})){
    const parts = flatKey.split('.');
    let cur = res;
    for(let i=0;i<parts.length;i++){
      const p = parts[i];
      if(i === parts.length - 1){
        const val = flat[flatKey];
        if(typeof val === 'string'){
                    if(val.trim().startsWith('[') || val.trim().startsWith('{')){
            try{ 
              cur[p] = JSON.parse(val); 
              continue; 
            }catch(e){}
          }
                    if(!isNaN(val) && !isNaN(parseFloat(val)) && val.trim() !== ''){
            const num = parseFloat(val);
            if(num.toString() === val.trim()){
              cur[p] = num;
              continue;
            }
          }
                    if(val.toLowerCase() === 'true'){
            cur[p] = true;
            continue;
          }
          if(val.toLowerCase() === 'false'){
            cur[p] = false;
            continue;
          }
                    if(val.toLowerCase() === 'null'){
            cur[p] = null;
            continue;
          }
          if(val.toLowerCase() === 'undefined'){
            cur[p] = undefined;
            continue;
          }
        }
        cur[p] = val;
      } else {
        if(!cur[p] || typeof cur[p] !== 'object') cur[p] = {};
        cur = cur[p];
      }
    }
  }
  return res;
}

function getRowsFromJson(parsed){
  if(Array.isArray(parsed)){
    state.originalParsed = { type: 'array' };
    return parsed.map(o=>flattenObject(o));
  }
  for(const k of Object.keys(parsed || {})){
    if(Array.isArray(parsed[k])){
      state.originalParsed = { type: 'rootKeyArray', key: k, template: parsed };
      return parsed[k].map(o=>flattenObject(o));
    }
  }
  state.originalParsed = { type: 'object' };
  return [flattenObject(parsed)];
}

function tryParseJson(text){
  try{ 
    return JSON.parse(text); 
  }catch{
    try {
      const clean = text.replace(/(['"])?([a-zA-Z0-9_]+)(['"])?\s*:/g, '"$2":');
      return JSON.parse(clean);
    }catch{ 
      return null; 
    }
  }
}

function dynamicFilename(ext){
  const d = new Date();
  const pad = n=> (n<10?'0':'')+n;
  return `JSON_${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.${ext}`;
}

function rowsToCsv(rows, sep){
  if(!rows.length) return '';
  const keys = Array.from(rows.reduce((s,r)=>{ 
    Object.keys(r).forEach(k=>s.add(k)); 
    return s; 
  }, new Set()));
  const esc = v=>{
    if(v==null) return '';
    const s = String(v);
    if(s.includes('"') || s.includes('\n') || s.includes(sep)) {
      return `"${s.replace(/"/g,'""')}"`;
    }
    return s;
  };
  const lines = [keys.join(sep)];
  for(const r of rows) {
    lines.push(keys.map(k=>esc(r[k])).join(sep));
  }
  return lines.join('\n');
}

function escapeHtml(s){ 
  return (s||'').replace(/[&<>"']/g, c=>({ 
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' 
  })[c]); 
}

function escapeAttribute(s){ 
  return (s||'').replace(/"/g,'&quot;'); 
}

function formatMessage(template, data) {
  if (!template) return '';
  return Object.entries(data || {}).reduce((acc, [key, value]) => {
    return acc.replace(new RegExp(`{{${key}}}`, 'g'), String(value));
  }, template);
}

// v1.2.20 – helper local para escapar cadenas en RegExp
function escapeRegExp(str) {
  return String(str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// v1.2.1 – soporte de números regionales en la tabla
function isNumericLike(value) {
  if (value === null || value === undefined) return false;
  if (typeof value === 'number') return Number.isFinite(value);
  if (typeof value !== 'string') return false;

  const trimmed = value.trim();
  if (!trimmed) return false;

  const normalized = trimmed.replace(/\s/g, '').replace(',', '.');
  return !Number.isNaN(Number(normalized));
}

function formatNumber(value) {
  const locale = state.currentLanguage === 'es' ? 'es-AR' : 'en-US';

  if (typeof value === 'number') {
    return new Intl.NumberFormat(locale, {
      minimumFractionDigits: 0,
      maximumFractionDigits: 10,
      useGrouping: true
    }).format(value);
  }

  const normalized = String(value).replace(',', '.');
  const parsed = Number(normalized);
  if (Number.isNaN(parsed)) return value;

  const hasDecimal = normalized.includes('.');

  return new Intl.NumberFormat(locale, {
    minimumFractionDigits: hasDecimal ? 2 : 0,
    maximumFractionDigits: 10,
    useGrouping: true
  }).format(parsed);
}

function applyDataTranslations() {
  // Actualizar textos con data-i18n
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    if (!key) return;
    const text = t(key);
    if (text !== undefined && text !== key) {
      el.textContent = text;
    }
  });

  const attrMap = [
    ['data-i18n-placeholder', 'placeholder'],
    ['data-i18n-title', 'title'],
    ['data-i18n-aria-label', 'aria-label']
  ];

  attrMap.forEach(([dataAttr, attr])=>{
    document.querySelectorAll(`[${dataAttr}]`).forEach(el => {
      const key = el.getAttribute(dataAttr);
      if(!key) return;
      const text = t(key);
      if(text !== undefined) el.setAttribute(attr, text);
    });
  });

  const badgeText = document.querySelector('#editModeBadge [data-i18n="editModeActive"]');
  if(badgeText) badgeText.textContent = t('editModeActive');
}

function clearAllFilters(){
  state.columnFilters = {};
  if(el.filterGlobal){
    el.filterGlobal.value = '';
  }
  if(el.filterGlobalClearBtn){
    el.filterGlobalClearBtn.style.display = 'none';
  }
  try {
    localStorage.removeItem('globalFilter');
  } catch (e) {
    console.warn('No se pudo limpiar el filtro global persistido:', e);
  }
  invalidateFilterCache();
  updateClearButtons();
}

function updateUITexts(){
    // Función auxiliar para actualizar texto de un elemento por ID
    function updateElementText(id, text) {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = text;
        } else if (id) { // Solo mostrar advertencia si el ID no está vacío
            console.warn(`Elemento con ID '${id}' no encontrado`);
        }
    }

    // 1. Aplicar traducciones a elementos con atributos data-i18n
    applyDataTranslations();

    // 2. Actualizar textos de elementos específicos
    const translations = {
        // Botones principales
        'clearJson': { element: el.clearBtn },
        'showRaw': { element: el.toggleRawBtn },
        'copyTable': { element: el.copyBtn },
        'edit': { element: el.editBtn, condition: !state.editing },
        'save': { element: el.editBtn, condition: state.editing },
        
        // Campos de formulario
        'globalFilter': { element: el.filterGlobal, attr: 'placeholder' },
        'historySearchPlaceholder': { element: el.historySearchInput, attr: 'placeholder' },
        
        // Pestañas y secciones
        'configuration': { id: 'tabConfigText' },
        'customTheme': { id: 'tabCustomText' },
        'language': { id: 'languageLabel' },
        'selectLanguageOption': { id: 'languageSelected' },
        'jsonHistory': { id: 'historyLabel' },
        'load': { id: 'loadHistoryText' },
        'rename': { id: 'renameHistoryText' },
        'delete': { id: 'deleteHistoryText' },
        'webMobile': { id: 'mobileSwitchText' },
        'separator': { id: 'separatorLabel' },
        'download': { id: 'downloadOption' },
        
        // Tema personalizado
        'customizeTheme': { id: 'customThemeTitle' },
        'background': { id: 'bgColorLabel' },
        'text': { id: 'textColorLabel' },
        'headerCells': { id: 'headerColorLabel' },
        'typography': { id: 'fontFamilyLabel' },
        'evenCells': { id: 'cellEvenLabel' },
        'oddCells': { id: 'cellOddLabel' },
        'default': { id: 'customDefaultText' }
    };

    // Aplicar traducciones
    Object.entries(translations).forEach(([key, { element, id, attr, condition }]) => {
        if (condition === false) return;
        
        const text = t(key);
        if (text === undefined) return;
        
        if (element) {
            if (attr) {
                element[attr] = text;
            } else {
                element.textContent = text;
            }
        } else if (id) {
            // Actualizar el texto del interruptor móvil si existe
  const mobileSwitch = document.getElementById('mobileSwitchText');
  if (mobileSwitch) {
    mobileSwitch.textContent = t('webMobile');
  }
        }
    });

    if (el.languageSelected && !state.selectedLanguage){
        el.languageSelected.textContent = t('selectLanguageOption');
    }

    if (el.jsonHistorySelected && (state.selectedHistoryIndex === null || state.selectedHistoryIndex === '')) {
        el.jsonHistorySelected.textContent = t('selectJsonOption');
    }

    if (el.themePresetSelected && !state.selectedThemePreset) {
        el.themePresetSelected.textContent = t('themePresetPlaceholder');
    }

    // Eliminar configuración insegura de X-Frame-Options y CSP del meta tag
    const metaTags = document.getElementsByTagName('meta');
    for (let i = 0; i < metaTags.length; i++) {
        const metaTag = metaTags[i];
        if (metaTag.httpEquiv === 'X-Frame-Options' || metaTag.httpEquiv === 'Content-Security-Policy') {
            metaTag.remove();
        }
    }

    // 3. Actualizar opciones del selector de idioma
    const languageOptions = {
        'languageEnglishDefault': 'languageOptionEn',
        'languageSpanish': 'languageOptionEs'
    };
    
    Object.entries(languageOptions).forEach(([key, id]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = t(key);
        }
    });

    // 4. Actualizar el historial y la tabla
    renderHistoryDropdown();
  renderLanguageDropdown();
    
    // 5. Forzar actualización de textos en la tabla
    if (state.currentRows && state.currentRows.length > 0) {
        renderTable();
    }
}

if(el.historySearchInput){
  el.historySearchInput.placeholder = t('historySearchPlaceholder');
  el.historySearchInput.addEventListener('input', debounce((e)=>{
    state.historyFilter = e.target.value || '';
    renderHistoryDropdown();
  }, 200));
}

function getLanguageLabel(code){
  const map = {
    en: t('languageEnglishDefault') || 'English',
    es: t('languageSpanish') || 'Español'
  };
  return map[code] || code;
}

function updateLanguageSelectedLabel(code){
  if(!el.languageSelected) return;
  
  if (code && code !== 'selectLanguageOption') {
    const label = getLanguageLabel(code);
    el.languageSelected.textContent = label;
    el.languageSelected.setAttribute('data-i18n', ''); // Eliminar data-i18n para evitar conflictos
  } else {
    el.languageSelected.textContent = t('selectLanguageOption');
    el.languageSelected.setAttribute('data-i18n', 'selectLanguageOption');
  }
}

function renderLanguageDropdown(){
  if(!el.languageList) return;

  const languages = [
    { code: 'en', label: t('languageEnglishDefault') || 'English' },
    { code: 'es', label: t('languageSpanish') || 'Español' }
  ];

  el.languageList.innerHTML = '';

  languages.forEach(lang => {
    const item = document.createElement('button');
    item.type = 'button';
    item.className = 'language-preset-item';
    item.setAttribute('role', 'option');
    item.setAttribute('data-lang', lang.code);
    const isSelected = (state.selectedLanguage || state.currentLanguage) === lang.code;
    if(isSelected){
      item.setAttribute('aria-selected', 'true');
    }

    item.addEventListener('click', ()=>{
      closeLanguageDropdown();
      changeLanguage(lang.code);
    });

    const label = document.createElement('span');
    label.className = 'language-preset-name';
    label.textContent = lang.label;
    item.appendChild(label);

    el.languageList.appendChild(item);
  });
}

function openLanguageDropdown(){
  if(!el.languageDropdown || !el.languageToggle) return;
  el.languageDropdown.hidden = false;
  el.languageToggle.setAttribute('aria-expanded', 'true');
  renderLanguageDropdown();
}

function closeLanguageDropdown(){
  if(!el.languageDropdown || !el.languageToggle) return;
  el.languageDropdown.hidden = true;
  el.languageToggle.setAttribute('aria-expanded', 'false');
}

function toggleLanguageDropdown(){
  if(!el.languageDropdown) return;
  if(el.languageDropdown.hidden){
    openLanguageDropdown();
  } else {
    closeLanguageDropdown();
  }
}

function changeLanguage(lang) {
  console.log('Iniciando cambio de idioma a:', lang);
  
  // Validar que el idioma sea soportado
  if (!['es', 'en'].includes(lang)) {
    console.warn(`Idioma no soportado: ${lang}. Usando español por defecto.`);
    lang = 'es';
  }
  
  // 1. Actualizar el estado y almacenamiento
  state.currentLanguage = lang;
  localStorage.setItem('preferredLanguage', lang);
  state.selectedLanguage = lang;
  
  // 2. Actualizar el selector de idioma
  if (el.languageSelect) {
    console.log('Actualizando selector de idioma a:', lang);
    el.languageSelect.value = lang;
  }

  updateLanguageSelectedLabel(lang);
  
  // 3. Actualizar la dirección del documento para idiomas RTL si es necesario
  document.documentElement.lang = lang;
  document.documentElement.dir = lang === 'ar' || lang === 'he' ? 'rtl' : 'ltr';
  
  // 4. Actualizar todos los textos de la interfaz
  console.log('Actualizando textos de la interfaz...');
  updateUITexts();
  
  // 5. Actualizar elementos específicos que podrían necesitar atención especial
  console.log('Actualizando elementos dinámicos...');
  
  // Actualizar el título de la página
  document.title = t('appTitle');
  
  // 6. Forzar actualización de la tabla para asegurar que todos los textos se actualicen
  console.log('Volviendo a renderizar la tabla...');
  if (state.currentRows && state.currentRows.length > 0) {
    renderTable();
  }
  
  // 7. Actualizar cualquier otro estado que dependa del idioma
  if (el.editBtnText) {
    el.editBtnText.textContent = state.editing ? t('save') : t('edit');
  }
  
  console.log('Cambio de idioma completado a:', lang);
  
  // 8. Actualizar elementos con data-i18n
  applyDataTranslations();
}

function saveColumnFilters(){
  try{
    localStorage.setItem('columnFilters', JSON.stringify(state.columnFilters || {}));
  }catch(e){
    console.warn('Error guardando filtros de columna:', e);
  }
}

function loadColumnFilters(){
  try{
    const raw = localStorage.getItem('columnFilters');
    if(raw){
      const parsed = JSON.parse(raw);
      if(typeof parsed === 'object' && parsed !== null){
        state.columnFilters = parsed;
      }
    }
  }catch(e){
    console.warn('Error cargando filtros de columna:', e);
    state.columnFilters = {};
  }
}

function loadHistory(){
  try{
    const raw = localStorage.getItem('jsonHistory');
    if(!raw){
      state.history = [];
      renderHistoryDropdown();
      return;
    }
    const parsed = JSON.parse(raw);
    if(Array.isArray(parsed)){
      state.history = parsed.slice(-HISTORY_MAX_ENTRIES);
    } else {
      state.history = [];
    }
    renderHistoryDropdown();
  }catch(e){
    console.warn('loadHistory', e);
    state.history = [];
    renderHistoryDropdown();
  }
}

function renderHistoryDropdown(){
  if(!el.jsonHistoryList || !Array.isArray(state.history)) return;

  const filter = (state.historyFilter || '').toLowerCase();
  const list = el.jsonHistoryList;
  list.innerHTML = '';

  let needsSave = false;
  state.history = state.history.slice(0, HISTORY_MAX_ENTRIES).map((item, idx) => {
    if (!item.name) {
      item.name = `JSON ${idx + 1}`;
      needsSave = true;
    }
    return item;
  });
  if (needsSave) saveHistory();

  const decorated = state.history.map((item, idx) => {
    const size = typeof item.size === 'number' ? item.size : new Blob([item.data || '']).size;
    if (item.size !== size) {
      item.size = size;
      needsSave = true;
    }
    return { ...item, idx, size };
  }).sort((a, b) => {
    const dateA = a.date ? new Date(a.date).getTime() : 0;
    const dateB = b.date ? new Date(b.date).getTime() : 0;
    return dateB - dateA;
  });

  const filtered = decorated.filter(item => {
    if (!filter) return true;
    return (
      (item.name || '').toLowerCase().includes(filter) ||
      (item.data || '').toLowerCase().includes(filter)
    );
  });

  if(filtered.length === 0){
    const empty = document.createElement('div');
    empty.className = 'history-presets-empty';
    empty.textContent = t('noHistoryItems');
    list.appendChild(empty);
    if(el.jsonHistorySelected) el.jsonHistorySelected.textContent = t('selectJsonOption');
    if(el.historyMeta) el.historyMeta.textContent = t('noHistoryItems');
    state.selectedHistoryIndex = null;
    return;
  }

  filtered.forEach(item => {
    const entry = document.createElement('div');
    entry.className = 'history-preset-item';
    entry.setAttribute('role', 'option');
    entry.setAttribute('data-index', item.idx);

    const nameBtn = document.createElement('button');
    nameBtn.type = 'button';
    nameBtn.className = 'history-preset-name';
    
    // Crear contenedor para el nombre y la información
    const nameContainer = document.createElement('div');
    nameContainer.style.display = 'flex';
    nameContainer.style.flexDirection = 'column';
    nameContainer.style.alignItems = 'flex-start';
    
    // Nombre del JSON
    const nameElement = document.createElement('div');
    nameElement.textContent = item.name || `JSON ${item.idx + 1}`;
    
    // Información de fecha y tamaño
    const infoElement = document.createElement('div');
    infoElement.style.fontSize = '10px';
    infoElement.style.opacity = '0.8';
    infoElement.style.marginTop = '2px';
    
    const dateStr = item.date ? new Date(item.date).toLocaleString() : '';
    const sizeStr = formatBytes(item.size);
    infoElement.textContent = dateStr ? `(${dateStr} • ${sizeStr})` : `(${sizeStr})`;
    
    // Agregar elementos al contenedor
    nameContainer.appendChild(nameElement);
    nameContainer.appendChild(infoElement);
    nameBtn.appendChild(nameContainer);
    
    const baseName = item.name || `JSON ${item.idx + 1}`;
    nameBtn.addEventListener('click', () => {
      state.selectedHistoryIndex = item.idx;
      if(el.jsonHistorySelected) el.jsonHistorySelected.textContent = baseName;
      loadHistoryItem(item.idx);
      closeHistoryDropdown();
    });

    const actions = document.createElement('div');
    actions.className = 'history-inline-actions';

    const renameBtn = document.createElement('button');
    renameBtn.type = 'button';
    renameBtn.className = 'history-inline-btn history-inline-rename';
    renameBtn.innerHTML = '<span aria-hidden="true">✏️</span>';
    renameBtn.setAttribute('aria-label', t('rename'));
    renameBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const listItem = e.target.closest('.history-preset-item');
      const nameBtn = listItem.querySelector('.history-preset-name');
      const nameElement = nameBtn.querySelector('div:first-child');
      
      // Obtener el nombre actual del elemento (solo el nombre, sin fecha/tamaño)
      let currentName = item.name || `JSON ${item.idx + 1}`;
      
      // Crear input para edición
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentName;
      input.className = 'history-edit-input';
      input.style.width = '100%';
      input.style.padding = '4px';
      input.style.border = '1px solid var(--accent)';
      input.style.borderRadius = '4px';
      
      // Guardar el HTML original para restaurarlo si es necesario
      const originalHTML = nameBtn.innerHTML;
      
      // Reemplazar el contenido con solo el input
      nameBtn.innerHTML = '';
      nameBtn.appendChild(input);
      input.focus();
      
      // Ocultar completamente los botones de acción
      const buttonsToDisable = listItem.querySelectorAll('.history-inline-btn');
      buttonsToDisable.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0';
        btn.style.visibility = 'hidden';
        btn.style.position = 'absolute';
        btn.style.pointerEvents = 'none';
        btn.style.width = '0';
        btn.style.height = '0';
        btn.style.overflow = 'hidden';
      });
      
      // Prevenir el cierre del panel al hacer clic en el input
      input.addEventListener('click', (e) => {
        e.stopPropagation();
      });
      
      // Enfocar el input al inicio y seleccionar todo el texto
      input.focus();
      input.select();
      
      // Función para guardar los cambios
      const saveEdit = (newName) => {
        try {
          const history = JSON.parse(localStorage.getItem('jsonHistory') || '[]');
          if (item.idx >= 0 && item.idx < history.length) {
            history[item.idx].name = newName;
            localStorage.setItem('jsonHistory', JSON.stringify(history));
            return true;
          }
        } catch (e) {
          console.error('Error al guardar el historial:', e);
        }
        return false;
      };

      // Función para restaurar la vista normal
      const restoreView = (newName) => {
        // Crear el HTML original con el nuevo nombre si se proporcionó
        const dateStr = item.date ? new Date(item.date).toLocaleString() : '';
        const sizeStr = formatBytes(item.size);
        
        // Actualizar el nombre actual si se proporciona uno nuevo
        if (newName !== undefined) {
          currentName = newName || `JSON ${item.idx + 1}`;
          
          // Actualizar el nombre en el objeto del historial
          const historyItem = state.history[item.idx];
          if (historyItem) {
            historyItem.name = currentName;
            // Forzar la actualización del historial
            if (typeof saveHistory === 'function') {
              saveHistory();
            } else {
              try {
                localStorage.setItem('jsonHistory', JSON.stringify(state.history));
              } catch (e) {
                console.error('Error al guardar en localStorage:', e);
              }
            }
            
            // Actualizar el ítem actual si es el seleccionado
            if (state.selectedHistoryIndex === item.idx && el.jsonHistorySelected) {
              el.jsonHistorySelected.textContent = currentName;
            }
          }
        }
        
        // Limpiar el contenido actual pero mantener las referencias a los botones
        nameBtn.innerHTML = '';
        
        // Restaurar el manejador de clic del botón principal
        const handleNameClick = () => {
          state.selectedHistoryIndex = item.idx;
          if(el.jsonHistorySelected) el.jsonHistorySelected.textContent = currentName || `JSON ${item.idx + 1}`;
          loadHistoryItem(item.idx);
          closeHistoryDropdown();
        };
        
        // Usar addEventListener en lugar de onclick para evitar sobrescribir otros manejadores
        nameBtn.removeEventListener('click', handleNameClick); // Eliminar cualquier manejador previo
        nameBtn.addEventListener('click', handleNameClick);
        
        // Crear el contenedor del nombre
        const nameContainer = document.createElement('div');
        nameContainer.className = 'history-preset-name';
        
        // Crear el texto del nombre
        const nameText = document.createElement('div');
        nameText.className = 'history-preset-name-text';
        nameText.textContent = currentName;
        
        // Crear la información adicional (fecha y tamaño)
        const infoText = document.createElement('div');
        infoText.className = 'history-preset-info';
        infoText.style.fontSize = '10px';
        infoText.style.opacity = '0.8';
        infoText.style.marginTop = '2px';
        infoText.textContent = dateStr ? `(${dateStr} • ${sizeStr})` : `(${sizeStr})`;
        
        // Agregar elementos al contenedor del nombre
        nameContainer.appendChild(nameText);
        nameContainer.appendChild(infoText);
        
        // Restaurar botones de acción
        const actions = document.createElement('div');
        actions.className = 'history-inline-actions';
        actions.style.position = 'absolute';
        actions.style.right = '8px';
        actions.style.top = '8px';
        
        // Crear botón de renombrar
        const newRenameBtn = document.createElement('button');
        newRenameBtn.type = 'button';
        newRenameBtn.className = 'history-inline-btn history-inline-rename';
        newRenameBtn.innerHTML = '<span aria-hidden="true">✏️</span>';
        newRenameBtn.setAttribute('aria-label', t('rename'));
        
        // Aplicar estilos directamente al botón
        newRenameBtn.style.width = '28px';
        newRenameBtn.style.height = '28px';
        newRenameBtn.style.display = 'inline-flex';
        newRenameBtn.style.alignItems = 'center';
        newRenameBtn.style.justifyContent = 'center';
        newRenameBtn.style.borderRadius = '6px';
        newRenameBtn.style.border = '1px solid var(--button-border)';
        newRenameBtn.style.background = 'var(--button-bg)';
        newRenameBtn.style.color = 'var(--fg)';
        newRenameBtn.style.cursor = 'pointer';
        newRenameBtn.style.transition = 'background 0.2s ease, transform 0.15s ease';
        newRenameBtn.style.fontSize = '15px';
        newRenameBtn.style.opacity = '1';
        newRenameBtn.style.visibility = 'visible';
        newRenameBtn.style.pointerEvents = 'auto';
        
        // Asignar el manejador de eventos original
        const handleRenameClick = (e) => {
          e.stopPropagation();
          
          // Obtener referencias a los elementos necesarios
          const listItem = e.target.closest('.history-preset-item');
          const nameBtn = listItem.querySelector('.history-preset-name');
          const nameElement = nameBtn.querySelector('.history-preset-name-text');
          
          // Obtener el nombre actual del elemento (solo el nombre, sin fecha/tamaño)
          // Usar el texto del elemento directamente para asegurar que tenemos el valor más reciente
          let currentName = nameElement ? nameElement.textContent.trim() : (item.name || `JSON ${item.idx + 1}`);
          
          // Actualizar el nombre en el objeto del ítem para mantener la consistencia
          if (item) {
            item.name = currentName;
          }
          
          // Crear input para edición
          const input = document.createElement('input');
          input.type = 'text';
          input.value = currentName;
          input.className = 'history-edit-input';
          input.style.width = '100%';
          input.style.padding = '4px';
          input.style.border = '1px solid var(--accent)';
          input.style.borderRadius = '4px';
          // Seleccionar todo el texto para facilitar la edición
          input.select();
          
          // Guardar el HTML original para restaurarlo si es necesario
          const originalHTML = nameBtn.innerHTML;
          
          // Reemplazar el contenido con solo el input
          nameBtn.innerHTML = '';
          nameBtn.appendChild(input);
          
          // Enfocar y seleccionar el texto después de un pequeño retraso
          // para asegurar que el elemento esté en el DOM
          setTimeout(() => {
            input.focus();
            input.select();
          }, 10);
          
          // Ocultar completamente los botones de acción
          const buttonsToDisable = listItem.querySelectorAll('.history-inline-btn');
          buttonsToDisable.forEach(btn => {
            btn.disabled = true;
            btn.style.opacity = '0';
            btn.style.visibility = 'hidden';
            btn.style.position = 'absolute';
            btn.style.pointerEvents = 'none';
            btn.style.width = '0';
            btn.style.height = '0';
            btn.style.overflow = 'hidden';
          });
          
          // Prevenir el cierre del panel al hacer clic en el input
          input.addEventListener('click', (e) => {
            e.stopPropagation();
          });
          
          // Guardar referencias a los botones originales
          const originalRenameBtn = listItem.querySelector('.history-inline-rename');
          const originalDeleteBtn = listItem.querySelector('.history-inline-delete');
          
          // Función para guardar los cambios
          const saveEdit = (newName) => {
            // Si el nombre está vacío, usar el predeterminado
            const finalName = newName || `JSON ${item.idx + 1}`;
            
            // Si no hay cambios, no hacer nada
            if (finalName === currentName) return true;
            
            try {
              // Actualizar el nombre en el estado local
              currentName = finalName;
              
              // Actualizar el nombre en el historial
              const historyItem = state.history[item.idx];
              if (historyItem) {
                historyItem.name = finalName;
                
                // Forzar una actualización del estado global
                state.history = [...state.history];
                
                // Guardar en localStorage
                try {
                  if (typeof saveHistory === 'function') {
                    saveHistory();
                  } else {
                    localStorage.setItem('jsonHistory', JSON.stringify(state.history));
                  }
                  
                  // Actualizar la interfaz para reflejar los cambios
                  if (state.selectedHistoryIndex === item.idx && el.jsonHistorySelected) {
                    el.jsonHistorySelected.textContent = finalName;
                  }
                  
                  return true;
                } catch (e) {
                  console.error('Error al guardar el historial:', e);
                  return false;
                }
              }
            } catch (e) {
              console.error('Error al guardar el nombre:', e);
            }
            return false;
          };
          
          // Función para limpiar los event listeners
          const cleanup = () => {
            input.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('mousedown', handleWindowClick);
          };
          
          // Manejador de teclado
          const handleKeyDown = (e) => {
            if (e.key === 'Enter' || e.key === 'Escape') {
              e.preventDefault();
              handleEdit(e);
            }
          };
          
          // Manejador de clic fuera del input
          const handleWindowClick = (e) => {
            if (input && !input.contains(e.target) && 
                !e.target.closest('.history-inline-rename') && 
                !e.target.closest('.history-inline-delete')) {
              // Guardar el valor actual antes de cerrar
              const newName = input.value.trim();
              if (newName && newName !== currentName) {
                saveEdit(newName);
              }
              // Llamar a handleEdit con un objeto que tenga el tipo de evento
              const fakeEvent = {
                type: 'blur',
                key: undefined,
                preventDefault: () => {},
                stopPropagation: () => {}
              };
              handleEdit(fakeEvent);
            }
          };
          
          // Función para restaurar el formato original del botón de nombre
          const restoreNameButton = (newName) => {
            // Crear el elemento de texto con el nuevo nombre
            const nameText = document.createElement('span');
            nameText.className = 'history-preset-name-text';
            nameText.textContent = newName || `JSON ${item.idx + 1}`;
            
            // Limpiar el botón y restaurar su estructura original
            nameBtn.innerHTML = '';
            nameBtn.appendChild(nameText);
            
            // Restaurar el botón de renombrar
            if (originalRenameBtn && originalRenameBtn.parentNode !== nameBtn) {
              nameBtn.appendChild(originalRenameBtn);
            }
            
            // Restaurar el botón de eliminar
            if (originalDeleteBtn && originalDeleteBtn.parentNode !== nameBtn) {
              nameBtn.appendChild(originalDeleteBtn);
            }
            
            // Restaurar los estilos del botón de nombre
            nameBtn.className = 'history-preset-name';
            nameBtn.style.display = 'flex';
            nameBtn.style.alignItems = 'center';
            nameBtn.style.justifyContent = 'space-between';
            nameBtn.style.width = '100%';
            nameBtn.style.overflow = 'hidden';
            nameBtn.style.textOverflow = 'ellipsis';
            nameBtn.style.whiteSpace = 'nowrap';
            
            // Restaurar los estilos del texto
            nameText.style.display = 'inline-block';
            nameText.style.overflow = 'hidden';
            nameText.style.textOverflow = 'ellipsis';
            nameText.style.whiteSpace = 'nowrap';
            nameText.style.maxWidth = 'calc(100% - 80px)';
            nameText.style.verticalAlign = 'middle';
            nameText.style.flex = '1';
            
            // Restaurar los botones de acción
            const actionButtons = nameBtn.querySelectorAll('.history-inline-btn');
            actionButtons.forEach(btn => {
              btn.style.display = 'flex';
              btn.style.alignItems = 'center';
              btn.style.justifyContent = 'center';
              btn.style.width = '24px';
              btn.style.height = '24px';
              btn.style.borderRadius = '4px';
              btn.style.border = '1px solid var(--button-border)';
              btn.style.background = 'var(--button-bg)';
              btn.style.color = 'var(--fg)';
              btn.style.cursor = 'pointer';
              btn.style.transition = 'all 0.2s ease';
              btn.style.opacity = '1';
              btn.style.visibility = 'visible';
              btn.style.pointerEvents = 'auto';
              
              // Asegurar que los botones tengan los manejadores correctos
              if (btn.classList.contains('history-inline-rename')) {
                btn.onclick = handleRenameClick;
              } else if (btn.classList.contains('history-inline-delete')) {
                btn.onclick = handleDeleteClick;
              }
            });
            
            return nameBtn;
          };
          
          // Manejador de edición
          const handleEdit = (e) => {
            const isKeyEvent = e && (e.key === 'Enter' || e.key === 'Escape');
            const isBlurEvent = e && e.type === 'blur';
            
            if (isKeyEvent || isBlurEvent) {
              if (e.preventDefault) e.preventDefault();
              if (e.stopPropagation) e.stopPropagation();
              
              let saved = false;
              
              // Si se presionó Enter o se perdió el foco, guardar cambios
              if (isKeyEvent || isBlurEvent) {
                const newName = input.value.trim();
                
                // Restaurar el formato del botón de nombre
                restoreNameButton(newName);
                
                // Guardar siempre, incluso si no hay cambios visibles
                saved = saveEdit(newName);
                
                // Si se presionó Escape, cancelar sin guardar
                if (e.key === 'Escape') {
                  saved = false;
                }
                // Si se presionó Enter sin cambios, considerar como guardado
                else if (isKeyEvent && e.key === 'Enter' && newName === currentName) {
                  saved = true;
                }
              }
              
              // Limpiar event listeners
              cleanup();
              
              // Restaurar la vista normal
              if (saved || (isKeyEvent && e.key === 'Enter' && e.key !== 'Escape')) {
                // Actualizar el nombre en la interfaz
                const displayName = currentName || `JSON ${item.idx + 1}`;
                
                // Reconstruir el HTML del botón con el nuevo nombre
                const dateStr = item.date ? new Date(item.date).toLocaleString() : '';
                const sizeStr = formatBytes(item.size);
                
                nameBtn.innerHTML = `
                  <div class="history-preset-name">
                    <div class="history-preset-name-text">${displayName}</div>
                    <div class="history-preset-info" style="font-size: 10px; opacity: 0.8; margin-top: 2px;">
                      ${dateStr ? `(${dateStr} • ${sizeStr})` : `(${sizeStr})`}
                    </div>
                  </div>
                  <div class="history-inline-actions" style="position: absolute; right: 8px; top: 8px;">
                    <button type="button" class="history-inline-btn history-inline-rename" style="width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; border-radius: 6px; border: 1px solid var(--button-border); background: var(--button-bg); color: var(--fg); cursor: pointer; transition: background 0.2s ease, transform 0.15s ease; font-size: 15px; opacity: 1; visibility: visible; pointer-events: auto;">
                      <span aria-hidden="true">✏️</span>
                    </button>
                    <button type="button" class="history-inline-btn history-inline-delete" style="width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; border-radius: 6px; border: 1px solid var(--button-border); background: var(--button-bg); color: var(--fg); cursor: pointer; transition: background 0.2s ease, transform 0.15s ease; font-size: 15px; margin-left: 4px; opacity: 1; visibility: visible; pointer-events: auto;">
                      <span aria-hidden="true">🗑️</span>
                    </button>
                  </div>
                `;
                
                // Restaurar los manejadores de eventos de los botones
                const newRenameBtn = nameBtn.querySelector('.history-inline-rename');
                const newDeleteBtn = nameBtn.querySelector('.history-inline-delete');
                
                if (newRenameBtn) {
                  newRenameBtn.onclick = handleRenameClick;
                  
                  // Restaurar estilos hover
                  newRenameBtn.addEventListener('mouseover', () => {
                    newRenameBtn.style.background = 'rgba(76, 175, 80, 0.2)';
                    newRenameBtn.style.borderColor = 'rgba(76, 175, 80, 0.4)';
                    newRenameBtn.style.transform = 'translateY(-1px)';
                  });
                  
                  newRenameBtn.addEventListener('mouseout', () => {
                    newRenameBtn.style.background = 'var(--button-bg)';
                    newRenameBtn.style.borderColor = 'var(--button-border)';
                    newRenameBtn.style.transform = 'none';
                  });
                }
                
                if (newDeleteBtn) {
                  newDeleteBtn.onclick = handleDeleteClick;
                  
                  // Restaurar estilos hover
                  newDeleteBtn.addEventListener('mouseover', () => {
                    newDeleteBtn.style.background = 'rgba(244, 67, 54, 0.2)';
                    newDeleteBtn.style.borderColor = 'rgba(244, 67, 54, 0.4)';
                    newDeleteBtn.style.transform = 'translateY(-1px)';
                  });
                  
                  newDeleteBtn.addEventListener('mouseout', () => {
                    newDeleteBtn.style.background = 'var(--button-bg)';
                    newDeleteBtn.style.borderColor = 'var(--button-border)';
                    newDeleteBtn.style.transform = 'none';
                  });
                }
                
                // Actualizar el texto seleccionado en el dropdown si es el elemento actual
                if (state.selectedHistoryIndex === item.idx && el.jsonHistorySelected) {
                  el.jsonHistorySelected.textContent = displayName;
                }
              } else if (e.key === 'Escape') {
                // Si se presionó Escape, restaurar la vista original
                nameBtn.innerHTML = originalHTML;
                
                // Restaurar los manejadores de eventos de los botones
                const newRenameBtn = listItem.querySelector('.history-inline-rename');
                const newDeleteBtn = listItem.querySelector('.history-inline-delete');
                
                if (newRenameBtn) {
                  newRenameBtn.onclick = handleRenameClick;
                }
                
                if (newDeleteBtn && originalDeleteBtn) {
                  newDeleteBtn.onclick = originalDeleteBtn.onclick;
                }
              }
            }
          };
          
          // Agregar event listeners
          input.addEventListener('keydown', handleKeyDown);
          
          // Usar un timeout para evitar que el clic que abrió la edición la cierre inmediatamente
          setTimeout(() => {
            document.addEventListener('mousedown', handleWindowClick);
          }, 0);
        };
        
        newRenameBtn.onclick = handleRenameClick;
        
        // Crear botón de eliminar
        const newDeleteBtn = document.createElement('button');
        newDeleteBtn.type = 'button';
        newDeleteBtn.className = 'history-inline-btn history-inline-delete';
        newDeleteBtn.innerHTML = '<span aria-hidden="true">🗑️</span>';
        newDeleteBtn.setAttribute('aria-label', t('delete'));
        
        // Aplicar estilos directamente al botón
        newDeleteBtn.style.width = '28px';
        newDeleteBtn.style.height = '28px';
        newDeleteBtn.style.display = 'inline-flex';
        newDeleteBtn.style.alignItems = 'center';
        newDeleteBtn.style.justifyContent = 'center';
        newDeleteBtn.style.borderRadius = '6px';
        newDeleteBtn.style.border = '1px solid var(--button-border)';
        newDeleteBtn.style.background = 'var(--button-bg)';
        newDeleteBtn.style.color = 'var(--fg)';
        newDeleteBtn.style.cursor = 'pointer';
        newDeleteBtn.style.transition = 'background 0.2s ease, transform 0.15s ease';
        newDeleteBtn.style.fontSize = '15px';
        newDeleteBtn.style.marginLeft = '4px';
        newDeleteBtn.style.opacity = '1';
        newDeleteBtn.style.visibility = 'visible';
        newDeleteBtn.style.pointerEvents = 'auto';
        
        // Asignar el manejador de eventos original del botón de eliminar
        const handleDeleteClick = (e) => {
          e.stopPropagation();
          
          // Si ya está en modo confirmación, no hacer nada
          const listItem = e.target.closest('.history-preset-item');
          if (listItem.classList.contains('confirm-delete')) return;
          
          // Poner el elemento en modo confirmación
          listItem.classList.add('confirm-delete');
          listItem.style.backgroundColor = 'rgba(255, 200, 200, 0.3)';
          listItem.style.borderLeft = '3px solid #ff4444';
          listItem.style.boxShadow = '0 0 8px rgba(255, 0, 0, 0.2)';
          listItem.style.transition = 'all 0.3s ease';
          
          // Agregar borde al elemento del historial seleccionado
          if (listItem) {
            listItem.style.border = '1px solid rgb(255, 68, 68)';
            listItem.style.borderRadius = '4px';
            listItem.style.transition = 'all 0.3s ease';
          }
          
          // Ocultar los botones actuales
          const actions = listItem.querySelector('.history-inline-actions');
          actions.style.display = 'none';
          
          // Crear contenedor de confirmación
          const confirmContainer = document.createElement('div');
          confirmContainer.className = 'delete-confirm-container';
          
          // Obtener posición del botón de eliminar y su contenedor
          const deleteBtn = listItem.querySelector('.history-inline-delete');
          const deleteBtnRect = deleteBtn.getBoundingClientRect();
          const listItemRect = listItem.getBoundingClientRect();
          
          // Estilos base del contenedor de confirmación
          Object.assign(confirmContainer.style, {
            display: 'flex',
            position: 'absolute',
            backgroundColor: 'rgba(255, 240, 240, 0.98)',
            border: '3px solid #ff4444',
            borderRadius: '6px',
            padding: '10px 14px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
            zIndex: '9999',
            alignItems: 'center',
            gap: '10px',
            maxWidth: '280px',
            minWidth: '200px',
            boxSizing: 'border-box',
            whiteSpace: 'nowrap',
            top: `${deleteBtnRect.top - listItemRect.top}px`,
            left: `${deleteBtnRect.right - listItemRect.left + 10}px`,
            transform: 'translateY(-50%)'
          });
          
          // Añadir el contenedor al DOM para poder calcular sus dimensiones
          document.body.appendChild(confirmContainer);
          
          // Función para actualizar la posición del contenedor
          const updateConfirmPosition = () => {
            const containerRect = confirmContainer.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const listItemRect = listItem.getBoundingClientRect();
            const buttonRect = deleteBtn.getBoundingClientRect();
            
            // Calcular posición relativa al ítem de la lista
            let posTop = buttonRect.top - listItemRect.top + (buttonRect.height / 2);
            let posLeft = buttonRect.right - listItemRect.left + 10;
            
            // Ajustar si se sale por la derecha del contenedor
            if (posLeft + containerRect.width > listItemRect.width) {
              posLeft = buttonRect.left - listItemRect.left - containerRect.width - 10;
              // Si aún así se sale por la izquierda, forzar posición dentro del contenedor
              if (posLeft < 0) {
                posLeft = 10;
                confirmContainer.style.maxWidth = `${listItemRect.width - 20}px`;
              }
            }
            
            // Ajustar posición vertical para mantener dentro del ítem
            if (posTop - (containerRect.height / 2) < 0) {
              posTop = containerRect.height / 2;
            } else if (posTop + (containerRect.height / 2) > listItemRect.height) {
              posTop = listItemRect.height - (containerRect.height / 2);
            }
            
            // Aplicar posición con ajuste de ventana
            const confirmRect = confirmContainer.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Ajustar posición horizontal si se sale de la ventana
            if (posLeft + confirmRect.width > windowWidth - 10) {
              posLeft = windowWidth - confirmRect.width - 10;
            }
            
            // Ajustar posición vertical si se sale de la ventana
            if (posTop + confirmRect.height > windowHeight - 10) {
              posTop = windowHeight - confirmRect.height - 10;
            } else if (posTop < 10) {
              posTop = 10;
            }
            
            confirmContainer.style.top = `${Math.max(10, posTop)}px`;
            confirmContainer.style.left = `${Math.max(10, posLeft)}px`;
            confirmContainer.style.position = 'fixed';
            confirmContainer.style.transform = 'none';
          };
          
          // Actualizar posición inicial
          updateConfirmPosition();
          
          // Manejador para actualizar posición al cambiar el tamaño o hacer scroll
          const handleUpdatePosition = () => updateConfirmPosition();
          
          // Agregar event listeners
          window.addEventListener('resize', handleUpdatePosition);
          window.addEventListener('scroll', handleUpdatePosition, true);
          
          // Limpiar los event listeners cuando se cancele o confirme
          const cleanupResizeListener = () => {
            window.removeEventListener('resize', handleUpdatePosition);
            window.removeEventListener('scroll', handleUpdatePosition, true);
          };
          
          // Crear botón de confirmación
          const confirmBtn = document.createElement('button');
          confirmBtn.textContent = t('confirmDelete');
          confirmBtn.className = 'confirm-delete-btn';
          confirmBtn.style.padding = '4px 12px';
          confirmBtn.style.border = '1px solid #ff4444';
          confirmBtn.style.borderRadius = '4px';
          confirmBtn.style.backgroundColor = '#ff4444';
          confirmBtn.style.color = 'white';
          confirmBtn.style.cursor = 'pointer';
          confirmBtn.style.transition = 'all 0.2s';
          
          // Crear botón de cancelar
          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = t('cancel');
          cancelBtn.className = 'cancel-delete-btn';
          cancelBtn.style.padding = '4px 12px';
          cancelBtn.style.border = '1px solid #ccc';
          cancelBtn.style.borderRadius = '4px';
          cancelBtn.style.backgroundColor = '#f0f0f0';
          cancelBtn.style.color = '#333';
          cancelBtn.style.cursor = 'pointer';
          cancelBtn.style.transition = 'all 0.2s';
          
          // Agregar botones al contenedor
          confirmContainer.appendChild(confirmBtn);
          confirmContainer.appendChild(cancelBtn);
          
          // Agregar el contenedor al documento
          document.body.appendChild(confirmContainer);
          
          // Posicionar el contenedor de confirmación
          const updatePosition = () => {
            const rect = listItem.getBoundingClientRect();
            const containerRect = confirmContainer.getBoundingClientRect();
            
            // Asegurarse de que el contenedor no se salga de la pantalla
            let left = rect.left - containerRect.width - 20;
            if (left < 10) left = 10; // Márgen mínimo
            
            confirmContainer.style.left = `${left}px`;
            confirmContainer.style.top = `${rect.top + (rect.height / 2) - (containerRect.height / 2)}px`;
          };
          
          // Actualizar posición inicial
          updatePosition();
          
          // Actualizar posición al cambiar el tamaño de la ventana
          const handleResize = () => updatePosition();
          window.addEventListener('resize', handleResize);
          
          // Manejador de clic fuera del contenedor de confirmación
          const handleClickOutside = (e) => {
            if (!confirmContainer.contains(e.target) && !listItem.contains(e.target)) {
              // Si se hace clic fuera del contenedor y fuera del ítem, cancelar
              cancelBtn.click();
            }
          };
          
          // Agregar manejador de clic fuera
          setTimeout(() => {
            document.addEventListener('click', handleClickOutside);
          }, 0);
          
          // Manejador de clic en confirmar
          const handleConfirm = (e) => {
            e.stopPropagation();
            // Eliminar el ítem del historial
            state.history.splice(item.idx, 1);
            saveHistory();
            renderHistoryDropdown();
            if (el.jsonHistorySelected) el.jsonHistorySelected.textContent = t('selectJsonOption');
            
            // Limpiar listeners y restaurar vista
            cleanupResizeListener();
            cleanup();
            
            // Forzar actualización de la interfaz
            if (confirmContainer.parentNode) {
              confirmContainer.remove();
            }
          };
          
          // Manejador de clic en cancelar
          const handleCancel = (e) => {
            e.stopPropagation();
            cleanupResizeListener();
            cleanup();
            
            // Asegurarse de que el contenedor se elimine
            if (confirmContainer.parentNode) {
              confirmContainer.remove();
            }
          };
          
          // Función para limpiar
          const cleanup = () => {
            // Restaurar estilos del ítem
            listItem.classList.remove('confirm-delete');
            listItem.style.backgroundColor = '';
            listItem.style.borderLeft = '';
            listItem.style.boxShadow = '';
            listItem.style.border = '';
            
            // Mostrar botones nuevamente
            if (actions) {
              actions.style.display = '';
            }
            
            // Limpiar listeners
            if (typeof document !== 'undefined') {
              document.removeEventListener('click', handleClickOutside);
            }
            
            // Eliminar botones de confirmación si existen
            if (confirmBtn) {
              confirmBtn.removeEventListener('click', handleConfirm);
            }
            if (cancelBtn) {
              cancelBtn.removeEventListener('click', handleCancel);
            }
          };
          
          // Agregar manejadores de eventos
          confirmBtn.addEventListener('click', handleConfirm);
          cancelBtn.addEventListener('click', handleCancel);
        };
        
        newDeleteBtn.onclick = handleDeleteClick;
        
        // Agregar estilos hover
        newRenameBtn.addEventListener('mouseover', () => {
          newRenameBtn.style.background = 'rgba(76, 175, 80, 0.2)';
          newRenameBtn.style.borderColor = 'rgba(76, 175, 80, 0.4)';
          newRenameBtn.style.transform = 'translateY(-1px)';
        });
        
        newRenameBtn.addEventListener('mouseout', () => {
          newRenameBtn.style.background = 'var(--button-bg)';
          newRenameBtn.style.borderColor = 'var(--button-border)';
          newRenameBtn.style.transform = 'none';
        });
        
        newDeleteBtn.addEventListener('mouseover', () => {
          newDeleteBtn.style.background = 'rgba(244, 67, 54, 0.2)';
          newDeleteBtn.style.borderColor = 'rgba(244, 67, 54, 0.4)';
          newDeleteBtn.style.transform = 'translateY(-1px)';
        });
        
        newDeleteBtn.addEventListener('mouseout', () => {
          newDeleteBtn.style.background = 'var(--button-bg)';
          newDeleteBtn.style.borderColor = 'var(--button-border)';
          newDeleteBtn.style.transform = 'none';
        });
        
        // Agregar botones al contenedor de acciones
        actions.appendChild(newRenameBtn);
        actions.appendChild(newDeleteBtn);
        
        // Agregar todo al botón principal
        nameBtn.appendChild(nameContainer);
        nameBtn.appendChild(actions);
        
        // Forzar un reflow para asegurar que los estilos se apliquen
        void nameBtn.offsetHeight;
      };

      // Manejar la edición
      const handleEdit = (e) => {
        // Solo procesar si es Enter, Escape o blur
        const isKeyEvent = e && (e.key === 'Enter' || e.key === 'Escape');
        const isBlurEvent = e && e.type === 'blur';
        
        if (isKeyEvent || isBlurEvent) {
          if (e.preventDefault) e.preventDefault();
          if (e.stopPropagation) e.stopPropagation();
          
          let saved = false;
          
          // Si se presionó Enter o se perdió el foco, guardar cambios
          if (isKeyEvent || isBlurEvent) {
            const newName = input.value.trim();
            if (newName && newName !== currentName) {
              saved = saveEdit(newName);
              if (saved) {
                currentName = newName;
              }
            }
          }
          
          // Limpiar event listeners
          input.removeEventListener('keydown', handleKeyDown);
          cleanup(); // Limpiar el event listener de mousedown
          
          // Si se presionó Escape, restaurar la vista original sin guardar
          if (e.key === 'Escape') {
            nameBtn.innerHTML = originalHTML;
            
            // Reasignar eventos y restaurar estilos de botones
            const buttonsToUpdate = nameBtn.querySelectorAll('.history-inline-btn');
            buttonsToUpdate.forEach(btn => {
              btn.disabled = false;
              btn.style.opacity = '';
              btn.style.visibility = '';
              btn.style.position = '';
              btn.style.pointerEvents = '';
              btn.style.width = '';
              btn.style.height = '';
              btn.style.overflow = '';
              
              // Reasignar eventos
              if (btn.classList.contains('history-inline-rename')) {
                btn.onclick = (e) => {
                  e.stopPropagation();
                  renameBtn.click();
                };
              } else if (btn.classList.contains('history-inline-delete')) {
                btn.onclick = (e) => {
                  e.stopPropagation();
                  deleteBtn.click();
                };
              }
            });
            
            // Restaurar el manejador de clic del botón principal
            nameBtn.onclick = () => {
              state.selectedHistoryIndex = item.idx;
              if(el.jsonHistorySelected) el.jsonHistorySelected.textContent = currentName || `JSON ${item.idx + 1}`;
              loadHistoryItem(item.idx);
              closeHistoryDropdown();
            };
            
            return;
          }
          
          // Si no fue Escape, restaurar la vista normal
          restoreView(saved ? input.value.trim() : null);
        }
      };
      
      const handleKeyDown = (e) => {
        if (e.key === 'Enter' || e.key === 'Escape') {
          e.preventDefault();
          handleEdit(e);
        }
      };
      
            // Usar mousedown en lugar de blur para tener más control sobre cuándo se cierra
      const handleWindowClick = (e) => {
        // Si el clic fue fuera del input y no en los botones
        if (input && !input.contains(e.target) && 
            !e.target.closest('.history-inline-rename') && 
            !e.target.closest('.history-inline-delete')) {
          // Guardar el valor actual antes de cerrar
          const newName = input.value.trim();
          if (newName && newName !== currentName) {
            saveEdit(newName);
          }
          // Llamar a handleEdit con un objeto que tenga el tipo de evento
          const fakeEvent = {
            type: 'blur',
            key: undefined,
            preventDefault: () => {},
            stopPropagation: () => {}
          };
          handleEdit(fakeEvent);
        }
      };
      
      // Usar un timeout para evitar que el clic que abrió la edición la cierre inmediatamente
      setTimeout(() => {
        document.addEventListener('mousedown', handleWindowClick);
      }, 0);
      
      // Manejar teclado
      input.addEventListener('keydown', handleKeyDown);
      
      // Limpiar el event listener cuando se termine la edición
      const cleanup = () => {
        document.removeEventListener('mousedown', handleWindowClick);
      };
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'history-inline-btn history-inline-delete';
    deleteBtn.innerHTML = '<span aria-hidden="true">🗑️</span>';
    deleteBtn.setAttribute('aria-label', t('delete'));
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Si ya está en modo confirmación, no hacer nada
      if (entry.classList.contains('confirm-delete')) return;
      
      // Poner el elemento en modo confirmación
      entry.classList.add('confirm-delete');
      entry.style.backgroundColor = 'rgba(255, 200, 200, 0.3)';
      entry.style.borderLeft = '3px solid #ff4444';
      entry.style.boxShadow = '0 0 8px rgba(255, 0, 0, 0.2)';
      entry.style.transition = 'all 0.3s ease';
      
      // Agregar borde al elemento del historial seleccionado
      if (entry) {
        entry.style.border = '1px solid rgb(255, 68, 68)';
        entry.style.borderRadius = '4px';
        entry.style.transition = 'all 0.3s ease';
      }
      
      // Ocultar los botones actuales
      actions.style.display = 'none';
      
      // Crear contenedor de confirmación centrado
      const confirmContainer = document.createElement('div');
      confirmContainer.className = 'delete-confirm-container';
      
      // Obtener dimensiones del elemento padre
      const rect = entry.getBoundingClientRect();
      const actionsRect = actions.getBoundingClientRect();
      
      // Estilos para el contenedor de confirmación
      Object.assign(confirmContainer.style, {
        display: 'flex',
        position: 'fixed',
        transform: 'none',
        maxWidth: '280px',
        minWidth: '200px',
        boxSizing: 'border-box',
        backgroundColor: 'rgba(255, 240, 240, 0.98)',
        border: '3px solid rgb(255, 0, 0)',
        borderRadius: '6px',
        padding: '8px 12px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
        zIndex: '9999',
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        textAlign: 'center',
        minWidth: 'auto',
        maxWidth: 'none',
        whiteSpace: 'nowrap',
        backdropFilter: 'blur(2px)'
      });
      
      // Mensaje de confirmación
      const confirmText = document.createElement('span');
      confirmText.textContent = t('deleteConfirm') || '¿Eliminar?';
      confirmText.style.marginRight = '6px';
      confirmText.style.fontWeight = '500';
      confirmText.style.color = '#d32f2f';
      
      // Botón de confirmar
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = t('confirm') || 'Sí';
      confirmBtn.style.padding = '2px 8px';
      confirmBtn.style.fontSize = '11px';
      confirmBtn.style.fontWeight = 'bold';
      confirmBtn.style.backgroundColor = '#ff4444';
      confirmBtn.style.color = 'white';
      confirmBtn.style.border = 'none';
      confirmBtn.style.borderRadius = '3px';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';
      confirmBtn.style.transition = 'all 0.15s';
      confirmBtn.style.minWidth = '30px';
      confirmBtn.onmouseenter = () => {
        confirmBtn.style.backgroundColor = '#ff2222';
        confirmBtn.style.transform = 'translateY(-1px)';
      };
      confirmBtn.onmouseleave = () => {
        confirmBtn.style.backgroundColor = '#ff4444';
        confirmBtn.style.transform = 'translateY(0)';
      };
      
      // Botón de cancelar
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = t('cancel') || 'No';
      cancelBtn.style.padding = '2px 8px';
      cancelBtn.style.fontSize = '11px';
      cancelBtn.style.fontWeight = '500';
      cancelBtn.style.backgroundColor = '#f5f5f5';
      cancelBtn.style.color = '#555';
      cancelBtn.style.border = '1px solid #ddd';
      cancelBtn.style.borderRadius = '3px';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.05)';
      cancelBtn.style.transition = 'all 0.15s';
      cancelBtn.style.minWidth = '30px';
      cancelBtn.onmouseenter = () => {
        cancelBtn.style.backgroundColor = '#e0e0e0';
        cancelBtn.style.transform = 'translateY(-1px)';
      };
      cancelBtn.onmouseleave = () => {
        cancelBtn.style.backgroundColor = '#f0f0f0';
        cancelBtn.style.transform = 'translateY(0)';
      };
      
      // Agregar manejadores de eventos
      confirmBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteHistoryItem(item.idx, true); // Pasar true para omitir la segunda confirmación
      });
      
      cancelBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        entry.classList.remove('confirm-delete');
        entry.style.backgroundColor = '';
        entry.style.borderLeft = '';
        entry.style.boxShadow = '';
        if (confirmContainer && confirmContainer.parentNode) {
          confirmContainer.remove();
        }
        actions.style.display = 'flex';
      });
      
      // Agregar elementos al contenedor
      confirmContainer.appendChild(confirmText);
      confirmContainer.appendChild(confirmBtn);
      confirmContainer.appendChild(cancelBtn);
      
      // Insertar el panel de confirmación justo antes de los botones de acción
      actions.parentNode.insertBefore(confirmContainer, actions);
      
      // Asegurar que el contenedor de acciones tenga posición relativa
      actions.style.position = 'relative';
      actions.style.paddingRight = '200px'; // Espacio para el panel de confirmación
      
      // Función para limpiar los estilos
      const cleanupStyles = () => {
        entry.classList.remove('confirm-delete');
        entry.style.removeProperty('background-color');
        entry.style.removeProperty('border-left');
        entry.style.removeProperty('box-shadow');
        entry.style.removeProperty('transition');
        actions.style.removeProperty('position');
        actions.style.removeProperty('padding-right');
        actions.style.removeProperty('display');
        
        // Restaurar estilos del elemento del historial
        if (entry) {
          entry.style.removeProperty('border');
          entry.style.removeProperty('border-radius');
          entry.style.removeProperty('transition');
        }
        
        if (confirmContainer && confirmContainer.parentNode) {
          confirmContainer.remove();
        }
      };

      // Cancelar la confirmación al hacer clic fuera
      const cancelOnClickOutside = (e) => {
        if (entry && !entry.contains(e.target)) {
          cleanupStyles();
          if (actions) {
            actions.style.display = 'flex';
          }
          document.removeEventListener('click', cancelOnClickOutside);
        }
      };

      // Manejar el clic en el botón de cancelar
      cancelBtn.onclick = (e) => {
        e.stopPropagation();
        cleanupStyles();
        actions.style.display = 'flex';
        document.removeEventListener('click', cancelOnClickOutside);
      };
      
      // Mostrar con animación
      setTimeout(() => {
        confirmContainer.style.opacity = '1';
        confirmContainer.style.transform = 'scale(1)';
      }, 10);
      
      // Asegurar que los botones originales se restablezcan si el elemento se elimina de otra manera
      const originalDisplay = window.getComputedStyle(actions).display;
      const resetButtons = () => {
        if (confirmContainer && confirmContainer.parentNode) {
          confirmContainer.remove();
        }
        actions.style.display = originalDisplay;
        document.removeEventListener('click', cancelOnClickOutside);
      };
      
      // Limpiar si el elemento se elimina del DOM
      const observer = new MutationObserver((mutations) => {
        if (!document.body.contains(entry)) {
          resetButtons();
          observer.disconnect();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
      
      // Usar setTimeout para evitar que el clic actual active el evento del documento
      setTimeout(() => {
        document.addEventListener('click', cancelOnClickOutside);
      }, 0);
    });

    actions.appendChild(renameBtn);
    actions.appendChild(deleteBtn);
    entry.appendChild(nameBtn);
    entry.appendChild(actions);
    list.appendChild(entry);
  });

  if(el.historyMeta){
    el.historyMeta.textContent = formatMessage(t('historyMeta'), { count: filtered.length });
  }

  if(needsSave) saveHistory();
}

function openHistoryDropdown(){
  if(!el.jsonHistoryDropdown || !el.jsonHistoryToggle) return;
  el.jsonHistoryDropdown.hidden = false;
  el.jsonHistoryToggle.setAttribute('aria-expanded', 'true');
}

function closeHistoryDropdown(){
  if(!el.jsonHistoryDropdown || !el.jsonHistoryToggle) return;
  el.jsonHistoryDropdown.hidden = true;
  el.jsonHistoryToggle.setAttribute('aria-expanded', 'false');
}

function toggleHistoryDropdown(){
  if(!el.jsonHistoryDropdown || !el.jsonHistoryToggle) return;
  const isOpen = el.jsonHistoryToggle.getAttribute('aria-expanded') === 'true';
  isOpen ? closeHistoryDropdown() : openHistoryDropdown();
}

function loadHistoryItem(index){
  const item = state.history[index];
  if(!item) return;
  el.jsonin.value = item.data;
  el.jsonin.dispatchEvent(new Event('input', { bubbles: true }));
  state.lastJson = item.data;
  announce('jsonLoaded');
}

function renameHistoryItem(index){
  const item = state.history[index];
  if(!item) return alert(t('selectJsonFromHistory'));
  const newName = prompt(t('newName'), item.name || '');
  if(newName){
    item.name = newName;
    saveHistory();
    renderHistoryDropdown();
  }
}

function deleteHistoryItem(index, skipConfirmation = false){
  const item = state.history[index];
  if(!item) return alert(t('selectItemToDelete'));
  
  // Si se debe omitir la confirmación (ya se mostró la interfaz personalizada)
  if (!skipConfirmation && !confirm(t('deleteFromHistory'))) return;
  state.history.splice(index, 1);
  saveHistory();
  renderHistoryDropdown();
  if(el.jsonHistorySelected) el.jsonHistorySelected.textContent = t('selectJsonOption');
}

function formatBytes(bytes){
  if(!Number.isFinite(bytes) || bytes <= 0) return '0 B';
  const units = ['B', 'KB', 'MB', 'GB', 'TB'];
  const idx = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
  const value = bytes / Math.pow(1024, idx);
  const fixed = value >= 10 || idx === 0 ? value.toFixed(0) : value.toFixed(1);
  return `${fixed} ${units[idx]}`;
}

async function sha1(str){
  const enc = new TextEncoder();
  const buf = await crypto.subtle.digest('SHA-1', enc.encode(str));
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

function saveHistory(){ 
  try{ 
    localStorage.setItem('jsonHistory', JSON.stringify(state.history)); 
  }catch(e){ 
    console.warn(e); 
  } 
}

async function addToHistory(jsonStr, name){
  if(!jsonStr || !jsonStr.trim()) return;
  if(jsonStr.length > HISTORY_MAX_JSON_SIZE){
    alert(t('historySizeExceeded') || 'El JSON es demasiado grande para guardar en el historial.');
    return;
  }
  const h = await sha1(jsonStr);
  const idx = state.history.findIndex(x => x.hash === h);
  if(idx >= 0){
    state.history[idx].date = new Date().toISOString();
  } else {
    state.history.push({ 
      hash: h, 
      data: jsonStr, 
      name: name || ('JSON ' + (state.history.length+1)), 
      date: new Date().toISOString() 
    });
    if(state.history.length > HISTORY_MAX_ENTRIES) state.history.shift();
  }
  saveHistory();
  renderHistoryDropdown();
}

function updateLastJsonStorage(text){
  if(!setLastJson(text)){
    console.warn('No se pudo guardar lastJson');
  }
}
function updateActionButtons() {
  const hasData = state.currentRows && state.currentRows.length > 0;
  const hasJsonInput = el.jsonin.value.trim().length > 0;
  const hasValidTable = hasData && !el.jsonin.classList.contains('error');

  // Elementos que requieren datos válidos para estar habilitados
  const actionElements = [
    el.downloadSelect,
    el.toggleRawBtn,
    el.copyBtn,
    el.editBtn,
    el.filterGlobal
  ];

  // Actualizar estado de los elementos de acción
  actionElements.forEach(element => {
    if (element) {
      element.disabled = !hasValidTable;
      // Si el elemento tiene un contenedor padre con clase 'action-container', lo mostramos/ocultamos
      const container = element.closest('.action-container');
      if (container) {
        container.style.display = hasValidTable ? '' : 'none';
      }
    }
  });

  // Botón de limpiar solo necesita que haya texto en el área de JSON
  if (el.clearBtn) {
    el.clearBtn.disabled = !hasJsonInput;
  }

  // Botones de historial
  // Botones de historial gestionados por acciones inline

  // Actualizar fila de filtro/edición
  if (el.filterEditRow) {
    if (hasValidTable) {
      el.filterEditRow.classList.remove('hide-without-data');
      el.filterEditRow.classList.add('show-with-data');
      el.filterEditRow.style.display = ''; // Asegurar que se muestre
    } else {
      el.filterEditRow.classList.add('hide-without-data');
      el.filterEditRow.classList.remove('show-with-data');
      el.filterEditRow.style.display = 'none'; // Asegurar que se oculte
    }
  }

  // Asegurarse de que el botón de edición muestre el texto correcto
  if (el.editBtn) {
    el.editBtn.textContent = state.editing ? t('save') : t('edit');
  }

  // Actualizar visibilidad del botón de limpiar filtro global
  if (el.filterGlobalClearBtn) {
    el.filterGlobalClearBtn.style.display = (hasValidTable && el.filterGlobal.value) ? 'block' : 'none';
  }
}

function showConfigTab(){
  el.tabConfig.classList.add('active');
  el.tabCustom.classList.remove('active');
  el.configContent.classList.add('active');
  el.configContent.style.display = 'block';
  el.customPanel.style.display = 'none';
  el.customPanel.classList.remove('active');
}

function showCustomTab(){
  el.tabCustom.classList.add('active');
  el.tabConfig.classList.remove('active');
  el.configContent.classList.remove('active');
  el.configContent.style.display = 'none';
  el.customPanel.style.display = 'block';
  el.customPanel.classList.add('active');
}

function clearCustomTheme(){
  const body = document.body;
  const html = document.documentElement;
  ['--bg','--fg','--cell-even','--cell-odd','--header-bg','--font-main','--custom-font-size'].forEach(prop => {
    body.style.removeProperty(prop);
    html.style.removeProperty(prop);
  });
}

function applyCustomTheme(colors){
  const root = document.documentElement;
  const body = document.body;
  const targets = [root, body];

  const setVar = (name, value) => {
    if (value == null) return;
    targets.forEach(t => t.style.setProperty(name, value));
  };

  if(colors.bg) setVar('--bg', colors.bg);
  if(colors.text) setVar('--fg', colors.text);
  if(colors.header) setVar('--header-bg', colors.header);
  if(colors.cellEven) setVar('--cell-even', colors.cellEven);
  if(colors.cellOdd) setVar('--cell-odd', colors.cellOdd);

  if(colors.font){
    setVar('--font-main', colors.font);
    const fontSelect = document.getElementById('fontFamily');
    if(fontSelect) fontSelect.value = colors.font;
  }

  if(colors.fontSize !== undefined){
    const fontSizeNum = Number(colors.fontSize);
    const resolvedSize = isNaN(fontSizeNum) ? 12 : fontSizeNum;
    const sizeValue = `${resolvedSize}px`;
    setVar('--custom-font-size', sizeValue);
    const fontSizeInput = document.getElementById('fontSize');
    if(fontSizeInput) fontSizeInput.value = resolvedSize;
  }

  if (typeof updateRowHeight === 'function') {
    updateRowHeight();
  }
}

function loadCustomTheme(){
  try{
    const isDark = document.body.classList.contains('dark');
    const themeKey = 'customTheme_' + (isDark ? 'dark' : 'light');
    const raw = localStorage.getItem(themeKey);
    const defaults = isDark ? {
      bg: '#141414',
      text: '#EEEEEE',
      header: '#222222',
      cellEven: '#252525',
      cellOdd: '#202020',
      font: "'Segoe UI', Tahoma, sans-serif",
      fontSize: 12
    } : {
      bg: '#ffffff',
      text: '#111111',
      header: '#f2f2f2',
      cellEven: '#f9f9f9',
      cellOdd: '#eef3ff',
      font: "'Segoe UI', Tahoma, sans-serif",
      fontSize: 12
    };

    const config = raw ? (()=>{
      try{
        const parsed = JSON.parse(raw);
        return {
          bg: parsed.bg || defaults.bg,
          text: parsed.text || defaults.text,
          header: parsed.header || defaults.header,
          cellEven: parsed.cellEven || defaults.cellEven,
          cellOdd: parsed.cellOdd || defaults.cellOdd,
          font: parsed.font || defaults.font,
          fontSize: Number(parsed.fontSize) || defaults.fontSize
        };
      }catch(parseError){
        console.warn('Error analizando tema personalizado, usando valores por defecto', parseError);
        return defaults;
      }
    })() : defaults;

    populateThemeControls(config);
    applyCustomTheme(config);
    saveCustomTheme(config);
  }catch(e){
    console.warn(e);
    applyCustomTheme({ text: '#111111' });
  }
  loadThemePresets();
}

function saveCustomTheme(config){
  const isDark = document.body.classList.contains('dark');
  const themeKey = 'customTheme_' + (isDark ? 'dark' : 'light');
  const c = config || {
    bg: el.bgColor.value,
    text: el.textColor.value,
    header: el.headerColor.value,
    font: el.fontFamily.value,
    cellEven: el.cellEven.value,
    cellOdd: el.cellOdd.value,
    fontSize: el.fontSize ? Number(el.fontSize.value) || 12 : 12
  };
  try {
    localStorage.setItem(themeKey, JSON.stringify(c));
  } catch (e) {
    console.warn('No se pudo guardar el tema personalizado:', e);
  }
  applyCustomTheme(c);
  return c;
}

function getThemePresetStorageKey(){
  const mode = document.body.classList.contains('dark') ? 'dark' : 'light';
  return `themePresets_${mode}`;
}

function collectThemeConfigFromInputs(){
  return {
    bg: el.bgColor ? el.bgColor.value : '#ffffff',
    text: el.textColor ? el.textColor.value : '#111111',
    header: el.headerColor ? el.headerColor.value : '#f2f2f2',
    cellEven: el.cellEven ? el.cellEven.value : '#ffffff',
    cellOdd: el.cellOdd ? el.cellOdd.value : '#f4f7ff',
    font: el.fontFamily ? el.fontFamily.value || "'Segoe UI', Tahoma, sans-serif" : "'Segoe UI', Tahoma, sans-serif",
    fontSize: el.fontSize ? Number(el.fontSize.value) || 12 : 12
  };
}

function loadThemePresets(){
  try {
    const raw = localStorage.getItem(getThemePresetStorageKey());
    const parsed = raw ? JSON.parse(raw) : [];
    state.themePresets = Array.isArray(parsed) ? parsed : [];
  } catch (e) {
    console.warn('Error al cargar temas guardados:', e);
    state.themePresets = [];
  }
  state.selectedThemePreset = '';
  renderThemePresetDropdown();
}

function saveThemePresets(list){
  const data = JSON.stringify(list || []);
  try {
    localStorage.setItem(getThemePresetStorageKey(), data);
  } catch (e) {
    console.warn('Error al guardar temas guardados:', e);
  }
  state.themePresets = Array.isArray(list) ? list : [];
  renderThemePresetDropdown();
}

function renderThemePresetDropdown(){
  if(!el.themePresetList) return;
  const list = el.themePresetList;
  list.innerHTML = '';

  const count = state.themePresets.length;
  if(count === 0){
    const empty = document.createElement('div');
    empty.className = 'theme-presets-empty';
    empty.textContent = t('noThemePresets');
    list.appendChild(empty);
    if(el.themePresetMeta){
      el.themePresetMeta.textContent = t('noThemePresets');
    }
    if(el.themePresetSelected){
      el.themePresetSelected.textContent = t('themePresetPlaceholder');
    }
    return;
  }

  state.themePresets.forEach((preset, index) => {
    const item = document.createElement('div');
    item.className = 'theme-preset-item';
    item.setAttribute('role', 'option');
    item.setAttribute('data-id', preset.id);
    item.setAttribute('tabindex', index === 0 ? '0' : '-1');

    const nameBtn = document.createElement('button');
    nameBtn.type = 'button';
    nameBtn.className = 'preset-name-btn';
    nameBtn.textContent = preset.name;
    nameBtn.title = t('loadThemePresetLabel');
    nameBtn.addEventListener('click', () => {
      state.selectedThemePreset = preset.id;
      applyThemePresetById(preset.id);
      closeThemePresetDropdown();
      if(el.themePresetSelected){
        el.themePresetSelected.textContent = preset.name;
      }
    });

    const actions = document.createElement('div');
    actions.className = 'preset-inline-actions';

    const renameBtn = document.createElement('button');
    renameBtn.type = 'button';
    renameBtn.className = 'preset-inline-btn preset-inline-rename';
    renameBtn.setAttribute('aria-label', t('renameThemePresetLabel'));
    renameBtn.innerHTML = '<span aria-hidden="true">✏️</span>';
    renameBtn.addEventListener('click', () => {
      state.selectedThemePreset = preset.id;
      const newName = prompt(t('renameThemePrompt'), preset.name);
      if(newName === null) return;
      renameThemePresetById(preset.id, newName);
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'preset-inline-btn preset-inline-delete';
    deleteBtn.setAttribute('aria-label', t('deleteThemePresetLabel'));
    deleteBtn.innerHTML = '<span aria-hidden="true">🗑️</span>';
    deleteBtn.addEventListener('click', () => {
      state.selectedThemePreset = preset.id;
      if(!confirm(t('confirmDeleteTheme'))) return;
      deleteThemePresetById(preset.id);
    });

    actions.appendChild(renameBtn);
    actions.appendChild(deleteBtn);

    item.appendChild(nameBtn);
    item.appendChild(actions);
    list.appendChild(item);
  });

  if(el.themePresetMeta){
    el.themePresetMeta.textContent = formatMessage(t('themePresetMeta'), { count });
  }
}

function openThemePresetDropdown(){
  if(!el.themePresetDropdown || !el.themePresetToggle) return;
  el.themePresetDropdown.hidden = false;
  el.themePresetToggle.setAttribute('aria-expanded', 'true');
}

function closeThemePresetDropdown(){
  if(!el.themePresetDropdown || !el.themePresetToggle) return;
  el.themePresetDropdown.hidden = true;
  el.themePresetToggle.setAttribute('aria-expanded', 'false');
}

function toggleThemePresetDropdown(){
  if(!el.themePresetDropdown || !el.themePresetToggle) return;
  const isOpen = el.themePresetToggle.getAttribute('aria-expanded') === 'true';
  if(isOpen){
    closeThemePresetDropdown();
  }else{
    openThemePresetDropdown();
  }
}

function populateThemeControls(config){
  if(!config) return;
  if(el.bgColor && config.bg) el.bgColor.value = config.bg;
  if(el.textColor && config.text) el.textColor.value = config.text;
  if(el.headerColor && config.header) el.headerColor.value = config.header;
  if(el.cellEven && config.cellEven) el.cellEven.value = config.cellEven;
  if(el.cellOdd && config.cellOdd) el.cellOdd.value = config.cellOdd;
  if(el.fontFamily && config.font) el.fontFamily.value = config.font;
  if(el.fontSize) el.fontSize.value = config.fontSize != null ? Number(config.fontSize) || 12 : 12;
}

function saveThemePreset(name){
  const trimmed = (name || '').trim();
  if(!trimmed){
    alert(t('requiredField'));
    return false;
  }
  const list = Array.isArray(state.themePresets) ? [...state.themePresets] : [];
  const exists = list.some(preset=> (preset.name || '').toLowerCase() === trimmed.toLowerCase());
  if(exists){
    alert(t('themePresetExists') || 'Ya existe un tema con ese nombre');
    return false;
  }
  const config = collectThemeConfigFromInputs();
  const normalizedConfig = JSON.stringify(config);
  const duplicateConfig = list.some(preset => JSON.stringify(preset.config) === normalizedConfig);
  if(duplicateConfig){
    alert(t('themePresetDuplicate') || 'Ya existe un tema con estas opciones');
    return false;
  }
  const preset = {
    id: `theme-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    name: trimmed,
    config: JSON.parse(JSON.stringify(config))
  };
  list.push(preset);
  state.selectedThemePreset = preset.id;
  saveThemePresets(list);
  saveCustomTheme(config);
  announce('themeSaved');
  return true;
}

function applyThemePresetById(id){
  if(!id) return false;
  const preset = state.themePresets.find(p => p.id === id);
  if(!preset) return false;
  populateThemeControls(preset.config);
  const stored = saveCustomTheme(preset.config);
  applyCustomTheme(stored);
  announce('themeLoaded');
  return true;
}

function renameThemePresetById(id, newName){
  const trimmed = (newName || '').trim();
  if(!trimmed){
    alert(t('requiredField'));
    return false;
  }
  const list = state.themePresets.map(preset =>
    preset.id === id ? { ...preset, name: trimmed } : preset
  );
  state.selectedThemePreset = id;
  saveThemePresets(list);
  announce('themeRenamed');
  return true;
}

function deleteThemePresetById(id){
  const list = state.themePresets.filter(preset => preset.id !== id);
  state.selectedThemePreset = '';
  saveThemePresets(list);
  announce('themeDeleted');
  return true;
}

function enableMobileMode(flag){
  state.mobileMode = !!flag;
  document.body.classList.toggle('mobile', !!flag);
  localStorage.setItem('mobileMode', state.mobileMode ? 'true' : 'false');
}

function updateFetchButtonState(){
  const url = el.urlIn.value.trim();
  const hasUrl = url.length > 0;
  const isDisabled = el.urlIn.disabled;
  const isValid = !hasUrl || validators.isValidUrl(url);
  
  // Actualizar estado del botón de carga
  el.fetchBtn.disabled = !hasUrl || isDisabled || !isValid;
  
  // Actualizar estilos visuales del campo de URL
  if (hasUrl) {
    el.urlIn.style.borderColor = isValid ? '' : '#ff6b6b';
    el.urlIn.style.boxShadow = isValid ? '' : '0 0 0 2px rgba(255, 107, 107, 0.2)';
  } else {
    el.urlIn.style.borderColor = '';
    el.urlIn.style.boxShadow = '';
  }
  
  // Actualizar estilos visuales del botón
  if (isDisabled) {
    el.fetchBtn.style.opacity = '0.6';
    el.fetchBtn.style.cursor = 'not-allowed';
    el.urlIn.style.opacity = '0.6';
    el.urlIn.style.cursor = 'not-allowed';
  } else {
    el.fetchBtn.style.opacity = hasUrl && isValid ? '1' : '0.6';
    el.fetchBtn.style.cursor = (hasUrl && isValid) ? 'pointer' : 'not-allowed';
    el.urlIn.style.opacity = '1';
    el.urlIn.style.cursor = 'text';
  }
}

async function parseJsonInput(addToHist) {
  const txt = el.jsonin.value || '';
  
  // Función para limpiar el estado cuando no hay texto
  const clearState = () => {
    state.originalParsed = null;
    state.originalRows = [];
    state.currentRows = [];
    state.currentHeaders = [];
    invalidateFilterCache();
    if (el.tableWrap) {
      el.tableWrap.innerHTML = '';
    }
    el.jsonin.classList.remove('error');
    // Ocultar controles que dependen de tener una tabla
    if (el.filterEditRow) {
      el.filterEditRow.style.display = 'none';
    }
    // Actualizar estado de los botones
    updateActionButtons();
  };
  
  // Si no hay texto, limpiar el estado y salir
  if (!txt.trim()) {
    clearState();
    return;
  }

  const parsed = tryParseJson(txt);
  if(!parsed){
        el.jsonin.classList.add('error');
    state.originalRows = []; 
    state.currentRows = [];
    try {
      if (el.tableWrap) {
        el.tableWrap.innerHTML = `
          <div class="error-message">
            <p>Error al mostrar la tabla. Por favor, verifica los datos e inténtalo de nuevo.</p>
            <button onclick="el.jsonin.focus(); el.jsonin.select();" class="btn">Revisar JSON</button>
          </div>`;
      }
    } catch (error) {
      console.error('Error al mostrar mensaje de error en renderTable:', error);
    }
  } else {
    el.jsonin.classList.remove('error');
  }

  try {
    const rows = getRowsFromJson(parsed);
    state.originalRows = rows;
    state.currentRows = rows.slice();
    state.lastParsedFull = parsed;
    invalidateFilterCache();

    // El modo de alto rendimiento ahora se gestiona automáticamente durante el renderizado
    // basado en el tamaño de los datos

    if (addToHist) {
      await addToHistory(txt);
      clearAllFilters();
    }

    updateLastJsonStorage(txt);
  } catch (error) {
    console.error('Error al procesar el JSON:', error);
    el.jsonin.classList.add('error');
    if (el.tableWrap) {
      el.tableWrap.innerHTML = `
        <div class="error-message">
          <p>Error al procesar el JSON: ${error.message}</p>
          <button onclick="el.jsonin.focus(); el.jsonin.select();" class="btn">Revisar JSON</button>
        </div>`;
    }
    return;
  }

  if(el.rawDisplay){
    el.rawDisplay.style.display = 'none';
  }
  if(el.tableWrap){
    el.tableWrap.style.display = '';
  }
  if(el.toggleRawBtn){
    el.toggleRawBtn.textContent = t('showRaw');
  }
  // Actualizar la visibilidad de los controles según si hay datos válidos
  const hasValidData = state.currentRows && state.currentRows.length > 0;
  
  // El filtro global y el botón de edición se manejarán en updateActionButtons
  // Solo asegurarse de que el contenedor padre esté configurado correctamente
  if (el.filterEditRow) {
    el.filterEditRow.style.display = hasValidData ? '' : 'none';
  }

    state.virtualStart = 0;
  computeVisibleCount();
  renderTable();
  updateActionButtons();
}

function saveLastJson(){ 
  try{ 
    localStorage.setItem('lastJson', el.jsonin.value || ''); 
  }catch(e){
    console.warn(e);
  } 
}

function debounce(fn, ms){
  let t;
  return function(...args){
    clearTimeout(t);
    t = setTimeout(()=> fn.apply(this, args), ms);
  };
}

function computeVisibleCount(){
  const h = el.tableWrap.clientHeight || 420;
  state.visibleCount = Math.ceil(h / state.rowHeight) + 6; }

function announce(key, data){
  if(!el.liveRegion) return;
  const template = t(key) || '';
  const message = formatMessage(template, data);
  if(!message) return;
  if(announceTimer) clearTimeout(announceTimer);
  el.liveRegion.textContent = '';
  announceTimer = setTimeout(()=>{
    el.liveRegion.textContent = message;
  }, 0);
}

let drawerLastFocus = null;

function toggleDrawer(open){
  if(!el.drawer) return;
  if(open){
    drawerLastFocus = document.activeElement;
    el.drawer.classList.add('open');
    document.body.classList.add('drawer-open');
    if(el.drawerOverlay){
      el.drawerOverlay.classList.add('visible');
      el.drawerOverlay.setAttribute('aria-hidden', 'false');
      // Asegurarse de que el overlay no sea enfocable
      el.drawerOverlay.removeAttribute('tabindex');
    }
    showConfigTab();
    const focusTarget = el.languageSelect || el.bgColor;
    if(focusTarget){
      setTimeout(()=>focusTarget.focus(), 0);
    }
  } else {
    el.drawer.classList.remove('open');
    document.body.classList.remove('drawer-open');
    if(el.drawerOverlay){
      el.drawerOverlay.classList.remove('visible');
      el.drawerOverlay.setAttribute('aria-hidden', 'true');
      // Hacer que el overlay no sea enfocable cuando está oculto
      el.drawerOverlay.removeAttribute('tabindex');
    }
    showConfigTab();
    if(drawerLastFocus && typeof drawerLastFocus.focus === 'function'){
      setTimeout(()=>drawerLastFocus.focus(), 0);
    }
  }
}

function updateEditBadgeCounter(){
  const badge = document.getElementById('editModeBadge');
  const counter = document.getElementById('editModeCount');
  if(!badge || !counter) return;
  const count = editedCellSet.size;
  counter.textContent = String(count);
  badge.setAttribute('data-count', String(count));
}

function updateClearButtons(){
  if(el.urlIn && el.urlClearBtn){
    el.urlClearBtn.style.display = el.urlIn.value ? 'block' : 'none';
  }
  if(el.filterGlobal && el.filterGlobalClearBtn){
    el.filterGlobalClearBtn.style.display = el.filterGlobal.value ? 'block' : 'none';
  }

  document.querySelectorAll('.filter-col').forEach(input => {
    const wrap = input.closest('.filter-col-wrap');
    if(!wrap) return;
    const clearBtn = wrap.querySelector('.filter-col-clear') || wrap.querySelector('.clear-btn');
    if(clearBtn){
      clearBtn.style.display = input.value ? 'block' : 'none';
    }
  });
}

function initClearButtons(){
  if(el.urlIn){
    ['input','focus','blur'].forEach(evt=>{
      el.urlIn.addEventListener(evt, updateClearButtons);
    });
  }
  if(el.filterGlobal){
    ['input','focus','blur'].forEach(evt=>{
      el.filterGlobal.addEventListener(evt, updateClearButtons);
    });
    try {
      const storedGlobal = localStorage.getItem('globalFilter');
      if (storedGlobal) {
        el.filterGlobal.value = storedGlobal;
      }
    } catch (e) {
      console.warn('No se pudo cargar el filtro global persistido:', e);
    }
  }

  updateClearButtons();
}

function getSortAriaLabel(columnKey){
  const colName = String(columnKey);
  const sortState = state.sortState[columnKey];
  let template;
  if(sortState === 'asc'){
    template = t('sortColumnAsc');
  } else if(sortState === 'desc'){
    template = t('sortColumnDesc');
  } else {
    template = t('sortColumnDefault');
  }
  return formatMessage(template || '', { column: colName });
}

function resetEditTracking() {
  editedCellSet.clear();
  updateEditBadgeCounter();
}

/**
 * Construye el HTML de una fila de la tabla
 * @param {Array} keys - Array de claves de las columnas
 * @param {Object} row - Objeto con los datos de la fila
 * @param {number} index - Índice de la fila
 * @returns {string} HTML de la fila
 */
function buildTableRow(keys, row, index, globalFilter = '') {
  try {
    const normalizedGlobal = (globalFilter || '').toLowerCase();
    const rowHasMatch = normalizedGlobal ? 
      Object.values(row).some(v => String(v || '').toLowerCase().includes(normalizedGlobal)) : 
      false;
    
    const rowClass = [];
    // No aplicar 'global-match' permanente; solo se hará blink tras el render
    if (index % 2 === 0) rowClass.push('even');
    
    let rowHtml = `<tr data-row="${index}" data-index="${index}" class="${rowClass.join(' ')}">`;
    
    // Celdas de datos
    keys.forEach(key => {
      const cellValue = row[key] !== undefined ? row[key] : '';

      let rawValue;
      if (cellValue === null || cellValue === undefined) {
        rawValue = '';
      } else if (typeof cellValue === 'object') {
        try {
          rawValue = JSON.stringify(cellValue);
        } catch (jsonError) {
          console.warn('No se pudo serializar el valor de la celda', cellValue, jsonError);
          rawValue = String(cellValue);
        }
      } else {
        rawValue = String(cellValue);
      }

      const normalizedValue = rawValue.toLowerCase();
      let displayValue = rawValue;
      if (!state.editing && isNumericLike(rawValue)) {
        displayValue = formatNumber(rawValue);
      }

      let cellContent = escapeHtml(String(displayValue));
      if (normalizedGlobal && normalizedValue.includes(normalizedGlobal)) {
        const regex = new RegExp(`(${escapeRegExp(normalizedGlobal)})`, 'gi');
        cellContent = cellContent.replace(regex, '<mark class="highlight">$1</mark>');
      }
      rowHtml += `<td class="editable" data-row="${index}" data-col="${encodeURIComponent(key)}" ` +
        `tabindex="0" draggable="true">${cellContent}</td>`;
    });

    // La columna de acciones ha sido eliminada para una interfaz más limpia
    rowHtml += '</tr>';
    return rowHtml;
    
  } catch (e) {
    console.error('Error al construir fila de la tabla:', e);
    return '';
  }
}

/**
 * Renderiza la tabla con scroll infinito y renderizado por chunks
 * @param {boolean} forceFullRender - Forzar renderizado completo
 */
 
function blinkCell(cell) {
  if (!cell) return;

  // Remover cualquier blink previo
  cell.classList.remove('blink-cell');

  // Forzar reflow para reiniciar la animación si se llama dos veces seguidas
  void cell.offsetWidth;

  const originalBackground = window.getComputedStyle(cell).getPropertyValue('background-color');
  cell.style.setProperty('--blink-origin', originalBackground);

  const handleAnimationEnd = () => {
    cell.classList.remove('blink-cell');
    cell.style.backgroundColor = originalBackground;

    requestAnimationFrame(() => {
      cell.style.backgroundColor = '';
      cell.style.setProperty('--blink-origin', '');
    });

    cell.removeEventListener('animationend', handleAnimationEnd);
  };

  cell.addEventListener('animationend', handleAnimationEnd);
  cell.classList.add('blink-cell');
}

function blinkMatch(el, className) {
  const blinkClass = `${className}-blink`;
  el.classList.add(className);
  el.classList.add(blinkClass);
  el.addEventListener(
    'animationend',
    () => {
      // Remover tanto la clase de blink como la base para evitar resaltado permanente
      el.classList.remove(blinkClass);
      el.classList.remove(className);
    },
    { once: true }
  );
}

function renderTable(forceFullRender = false) {
  try {
    const now = Date.now();
    const timeSinceLastRender = now - state.lastRenderTime;

    // Si no ha pasado el tiempo mínimo desde el último render, programar para más tarde
    if (timeSinceLastRender < state.minRenderInterval && !forceFullRender) {
      if (state.scrollDebounce) clearTimeout(state.scrollDebounce);
      state.scrollDebounce = setTimeout(() => renderTable(true), state.minRenderInterval - timeSinceLastRender);
      return;
    }

    state.lastRenderTime = now;
    
    // Definir clearMatches si no está disponible
    if (typeof clearMatches !== 'function') {
      window.clearMatches = function() {
        document.querySelectorAll('.blink-cell').forEach(el => {
          el.classList.remove('blink-cell');
        });
      };
    }
    
    clearMatches();
    
    // Validar que los elementos del DOM existan
    if (!el.tableWrap) {
      console.error('El contenedor de la tabla no existe');
      return;
    }

    // Asegurarse de que state.currentRows sea un array
    const rows = Array.isArray(state.currentRows) ? state.currentRows : [];
    
    // Obtener filas filtradas (usando caché si está disponible)
    const filtered = getFilteredRows(rows) || [];
    
    // Obtener claves de encabezado de manera segura
    const keys = [];
    try {
      const sourceForKeys = filtered.length > 0 ? filtered : rows;
      if (sourceForKeys.length > 0) {
        const headerKeys = getHeaderKeys(sourceForKeys) || [];
        keys.push(...headerKeys);
      }
    } catch (e) {
      console.error('Error al obtener claves de encabezado:', e);
    }

    state.currentHeaders = keys;

    // Calcular desplazamiento y filas visibles
    const scrollTop = el.tableWrap.scrollTop || 0;
    state.virtualStart = Math.max(0, Math.floor(scrollTop / state.rowHeight) - 3);
    computeVisibleCount();
    
    // Calcular el rango de filas a mostrar
    const visibleStart = state.virtualStart;
    const visibleEnd = Math.min(filtered.length, visibleStart + state.visibleCount);
    
    // Calcular los chunks que necesitamos renderizar
    const startChunk = Math.floor(visibleStart / state.chunkSize);
    const endChunk = Math.ceil(visibleEnd / state.chunkSize);
    
    // Activamos el renderizado por chunks automáticamente para conjuntos de datos grandes (>500 filas)
    const renderChunks = filtered.length > 500;
    
    // Construir el HTML de la tabla
    let html = '<table><thead><tr>';
    
    // Generar encabezados de la tabla
    keys.forEach(k => {
      try {
        const sortState = state.sortState || {};
        const cls = (sortState[k] === 'asc') ? 'order-asc' :
                   (sortState[k] === 'desc') ? 'order-desc' : '';
        const aria = getSortAriaLabel(k);
        const safeK = k ? String(k) : '';
        html += `<th class="${cls}" data-col="${encodeURIComponent(safeK)}" ` +
                `aria-label="${escapeAttribute(aria || '')}">${escapeHtml(safeK)}</th>`;
      } catch (e) {
        console.error('Error al generar encabezado de columna:', e);
      }
    });

    // La columna de acciones se ha eliminado para una interfaz más limpia
    
    html += '</tr>';

    // Fila de filtros
    html += '<tr class="filter-row">';
    keys.forEach(k => {
      try {
        const safeK = k ? String(k) : '';
        const columnFilters = state.columnFilters || {};
        const val = columnFilters[safeK] || '';

        html += `<th><span class="filter-col-wrap">` +
                `<input class="filter-col" data-col="${encodeURIComponent(safeK)}" ` +
                `value="${escapeAttribute(val)}" placeholder="${t('filterColumn')}" />` +
                `<button class="clear-btn filter-col-clear" data-col="${encodeURIComponent(safeK)}" ` +
                `title="${t('clearFilter')}" aria-label="${t('clearFilter')}" ` +
                `data-i18n-title="clearFilter" data-i18n-aria-label="clearFilter">✕</button>` +
                `</span></th>`;
      } catch (e) {
        console.error('Error al generar filtro de columna:', e);
      }
    });

    // La columna de acciones se ha eliminado completamente para una interfaz más limpia

    html += '</tr></thead><tbody>';

    // Espaciador superior para scroll virtual
    const topSpacerHeight = visibleStart * state.rowHeight;
    if (topSpacerHeight > 0) {
      html += `<tr style="height:${topSpacerHeight}px">`;
      html += `<td style="padding:0;border:none" colspan="${keys.length}"></td>`;
      html += '</tr>';
    }

    // Filas visibles
    if (filtered.length > 0) {
      const globalFilterValue = (el.filterGlobal?.value || '').toLowerCase();

      const renderRow = (row, absoluteIndex) => {
        const rowHtml = buildTableRow(keys, row, absoluteIndex, globalFilterValue);
        return rowHtml || '';
      };

      if (renderChunks) {
        const renderedChunks = new Set();
        for (let chunk = startChunk; chunk <= endChunk; chunk++) {
          const chunkStart = chunk * state.chunkSize;
          const chunkEnd = Math.min((chunk + 1) * state.chunkSize, filtered.length);

          if (chunkEnd > visibleStart && chunkStart < visibleEnd) {
            for (let rowIndex = chunkStart; rowIndex < chunkEnd; rowIndex++) {
              if (rowIndex >= visibleStart && rowIndex < visibleEnd) {
                html += renderRow(filtered[rowIndex], rowIndex);
              }
            }
            renderedChunks.add(chunk);
          }
        }
        state.renderedChunks = renderedChunks;
      } else {
        const visibleRows = filtered.slice(visibleStart, visibleEnd);
        visibleRows.forEach((row, index) => {
          html += renderRow(row, visibleStart + index);
        });
      }
    } else {
      // Mensaje cuando no hay filas que mostrar
      html += `<tr><td colspan="${keys.length}" class="no-results">`;
      html += t('noResults');
      html += '</td></tr>';
    }

    // Espaciador inferior para scroll virtual
    const bottomSpacerHeight = Math.max(0, (filtered.length - visibleEnd) * state.rowHeight);
    if (bottomSpacerHeight > 0) {
      html += `<tr style="height:${bottomSpacerHeight}px">`;
      html += `<td style="padding:0;border:none" colspan="${keys.length}"></td>`;
      html += '</tr>';
    }

    // Cerrar la tabla
    html += '</tbody></table>';

    // Actualizar el DOM
    el.tableWrap.innerHTML = html;
    
    // Adjuntar eventos
    attachTableEvents(filtered);
    updateActionButtons();
    updateClearButtons();

    // Aplicar blinks para filtros globales (aplicar a celdas con coincidencias)
    const globalFilter = (el.filterGlobal?.value || '').toLowerCase();
    if (globalFilter) {
      // Limpiar clases previas para evitar acumulaciones
      const existingMatches = el.tableWrap.querySelectorAll('.blink-cell');
      existingMatches.forEach(el => el.classList.remove('blink-cell'));
      
      // Aplicar blink a celdas que contienen palabras resaltadas
      el.tableWrap.querySelectorAll('tbody tr td mark.highlight').forEach(mark => {
        const td = mark.closest('td');
        const text = mark.textContent;
        if (td) {
          blinkCell(td);
        }
        mark.replaceWith(document.createTextNode(text));
      });
    }

    for (const [col, filter] of Object.entries(state.columnFilters || {})) {
      if (filter) {
        // Limpiar clases previas para columnas
        const existingMatches = el.tableWrap.querySelectorAll('.blink-cell');
        existingMatches.forEach(el => el.classList.remove('blink-cell'));
        
        const colIndex = state.currentHeaders.indexOf(col);
        if (colIndex >= 0) {
          const tds = el.tableWrap.querySelectorAll(`tbody tr td:nth-child(${colIndex + 1})`);
          tds.forEach((td, idx) => {
            const row = filtered[visibleStart + idx];
            if (row) {
              const displayValue = row[col] !== undefined ? String(row[col]) : '';
              if (displayValue.toLowerCase().includes(filter.toLowerCase())) {
                blinkCell(td);
              }
            }
          });
        }
      }
    }
    
  } catch (error) {
    console.error('Error en renderTable:', error);
    if (el.tableWrap) {
      el.tableWrap.innerHTML = `
        <div class="error-message">
          <p>Error al mostrar la tabla. Por favor, verifica los datos e inténtalo de nuevo.</p>
          <button onclick="location.reload()" class="btn">Recargar página</button>
        </div>`;
    }
  }
}

function setLastJson(text){
  const data = text || '';
  if(data.length > MAX_LAST_JSON_SIZE){
    alert(t('lastJsonSizeExceeded') || 'El JSON es demasiado grande para guardarlo localmente.');
    try{ localStorage.removeItem('lastJson'); }catch(e){ console.warn(e); }
    return false;
  }
  try{
    localStorage.setItem('lastJson', data);
    return true;
  }catch(e){
    console.warn(e);
    return false;
  }
}

function getFilterSignature(){
  const globalVal = (el.filterGlobal.value || '').toLowerCase();
  const columnVals = Object.entries(state.columnFilters || {})
    .map(([k,v])=>`${k}:${(v||'').toLowerCase()}`)
    .sort()
    .join('|');
  return `${globalVal}::${columnVals}`;
}

function getFilteredRows(rows){
  const signature = getFilterSignature();
  if(state.cache.filteredRows && state.cache.filterSignature === signature){
    return state.cache.filteredRows;
  }

  const globalVal = (el.filterGlobal.value || '').toLowerCase();
  const filtered = rows.filter(r=>{
    if(globalVal && !Object.values(r).some(v=>String(v||'').toLowerCase().includes(globalVal))){
      return false;
    }
    for(const [col,val] of Object.entries(state.columnFilters || {})){
      if(val && !(String((r[col]||'')).toLowerCase().includes(val.toLowerCase()))){
        return false;
      }
    }
    return true;
  });

  state.cache.filteredRows = filtered;
  state.cache.filterSignature = signature;
  return filtered;
}

function getHeaderKeys(rows){
  const signature = getFilterSignature();
  if(state.cache.headerKeys && state.cache.filterSignature === signature){
    return state.cache.headerKeys;
  }

  const keys = Array.from(rows.reduce((acc,row)=>{
    Object.keys(row).forEach(k=>acc.add(k));
    return acc;
  }, new Set()));

  state.cache.headerKeys = keys;
  state.cache.filterSignature = signature;
  return keys;
}

function invalidateFilterCache(){
  state.cache.filteredRows = null;
  state.cache.headerKeys = null;
  state.cache.filterSignature = '';
}

function buildTableHtml(rows, keys, showFilters = false){
  let html = `<table><thead><tr>`;

    keys.forEach(k => {
    const cls = (state.sortState[k] === 'asc') ? 'order-asc' : 
                (state.sortState[k] === 'desc') ? 'order-desc' : '';
    const aria = getSortAriaLabel(k);
    html += `<th class="${cls}" data-col="${encodeURIComponent(k)}" aria-label="${escapeAttribute(aria)}">${escapeHtml(k)}</th>`;
  });
    html += `</tr>`;

  if(showFilters){
    html += '<tr class="filter-row">';
    keys.forEach(k=>{
      const val = state.columnFilters[k] || '';
      html += `<th><span class="filter-col-wrap">
        <input class="filter-col" data-col="${encodeURIComponent(k)}"
               value="${escapeAttribute(val)}" placeholder="${t('filterColumn')}" />
        <button class="clear-btn filter-col-clear" data-col="${encodeURIComponent(k)}"
                title="${t('clearFilter')}" aria-label="${t('clearFilter')}" data-i18n-title="clearFilter" data-i18n-aria-label="clearFilter">✕</button>
      </span></th>`;
    });
    html += '</tr>';
  }

  html += '</thead><tbody>';
  if(!rows.length){
    html += `<tr><td colspan="${keys.length}" style="padding:12px;color:var(--muted)">
      ${t('noTable')}
    </td></tr>`;
  }
  html += '</tbody></table>';
  return html;
}

function attachTableEvents(filteredRows){
    el.tableWrap.querySelectorAll('th[data-col]').forEach(th=>{
    th.onclick = ()=>{
      const col = decodeURIComponent(th.dataset.col);
      const dir = (state.sortState[col] === 'asc') ? 'desc' : 'asc';
      state.sortState = {}; 
      state.sortState[col] = dir;

      state.currentRows.sort((a,b)=>{
        const va = a[col], vb = b[col];
        if(va==null) return 1; 
        if(vb==null) return -1;
        if(!isNaN(va) && !isNaN(vb)) {
          return dir==='asc' ? va - vb : vb - va;
        }
        return dir==='asc' ? 
          String(va).localeCompare(String(vb)) : 
          String(vb).localeCompare(String(va));
      });

      announce(dir === 'asc' ? 'sortAnnounceAsc' : 'sortAnnounceDesc', { column: col });
      invalidateFilterCache();
      el.tableWrap.scrollTop = 0;
      renderTable();
    };
  });

    const deb = debounce(function(){
        const activeElement = document.activeElement;
    const activeCol = activeElement && activeElement.classList.contains('filter-col') ? 
      decodeURIComponent(activeElement.dataset.col) : null;
    const activeValue = activeElement ? activeElement.value : '';

    renderTable();

        if(activeCol){
      setTimeout(()=>{
        const newInput = el.tableWrap.querySelector(`.filter-col[data-col="${encodeURIComponent(activeCol)}"]`);
        if(newInput){
          newInput.focus();
          newInput.value = activeValue;
                    newInput.setSelectionRange(activeValue.length, activeValue.length);
        }
      }, 0);
    }
  }, state.filterDebounceMs);

  el.tableWrap.querySelectorAll('.filter-col').forEach(inp=>{
    inp.addEventListener('input', (e)=> {
      const col = decodeURIComponent(inp.dataset.col);
      state.columnFilters[col] = inp.value;
      saveColumnFilters();
      deb();
    });

        inp.addEventListener('keydown', (e)=> { 
      e.stopPropagation();
    });

        inp.addEventListener('focus', (e)=> {
      e.stopPropagation();
    });
  });

    el.tableWrap.querySelectorAll('.filter-col-clear').forEach(btn=>{
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      const col = decodeURIComponent(btn.dataset.col);
    state.columnFilters[col] = '';
    saveColumnFilters();
      invalidateFilterCache();

            const input = document.querySelector(`.filter-col[data-col="${encodeURIComponent(col)}"]`);
      if (input) {
        input.value = '';
      }

            btn.style.display = 'none';

            renderTable();

            announce('filterCleared', { column: col });

            setTimeout(()=>{
        const selector = `.filter-col[data-col="${encodeURIComponent(col)}"]`;
        const newInp = el.tableWrap.querySelector(selector);
        if(newInp) {
          newInp.focus();
        }
      }, 0);
    });
  });

    if(state.editing){
    el.tableWrap.querySelectorAll('tbody td').forEach(td=>{
      td.contentEditable = 'true';
      td.classList.add('editable-cell');
      td.addEventListener('input', onCellEdit);
    });
  } else {
    el.tableWrap.querySelectorAll('tbody td').forEach(td=>{
      td.contentEditable = 'false';
      td.classList.remove('editable-cell');
      td.removeEventListener('input', onCellEdit);
    });
  }

    el.tableWrap.onscroll = function(){
    const scrollTop = el.tableWrap.scrollTop || 0;
    const newStart = Math.max(0, Math.floor(scrollTop / state.rowHeight) - 3);
    if(newStart !== state.virtualStart){
      state.virtualStart = newStart;
      renderTable();
    }
  };
}

function onCellEdit(e){
  const td = e.target;
  const virtualRowIdx = Number(td.dataset.row);
  const col = decodeURIComponent(td.dataset.col);
  const newVal = td.innerText;
  
  // Rastrear celdas editadas
  const cellKey = `${virtualRowIdx}:${col}`;
  if (state.editing) {
    editedCellSet.add(cellKey);
    updateEditBadgeCounter();
  }

  const actualIdx = virtualRowIdx;
  if(typeof actualIdx === 'number' && state.currentRows[actualIdx]){
    state.currentRows[actualIdx][col] = newVal;
  }

    if(state.originalParsed && state.originalParsed.type === 'array'){
    const newObj = unflattenObject(state.currentRows[actualIdx]);
    if(state.lastParsedFull && Array.isArray(state.lastParsedFull)){
      state.lastParsedFull[actualIdx] = newObj;
      const jsonStr = JSON.stringify(state.lastParsedFull, null, 2);
      updateLastJsonStorage(jsonStr);
      el.jsonin.value = jsonStr;
    }
  } else if(state.originalParsed && state.originalParsed.type === 'rootKeyArray'){
    const key = state.originalParsed.key;
    if(state.lastParsedFull && state.lastParsedFull[key] && Array.isArray(state.lastParsedFull[key])){
      const newObj = unflattenObject(state.currentRows[actualIdx]);
      state.lastParsedFull[key][actualIdx] = newObj;
      const jsonStr = JSON.stringify(state.lastParsedFull, null, 2);
      localStorage.setItem('lastJson', jsonStr);
      el.jsonin.value = jsonStr;
    }
  } else if(state.originalParsed && state.originalParsed.type === 'object'){
    const newObj = unflattenObject(state.currentRows[actualIdx]);
    state.lastParsedFull = newObj;
    const jsonStr = JSON.stringify(state.lastParsedFull, null, 2);
    updateLastJsonStorage(jsonStr);
    el.jsonin.value = jsonStr;
  }
}

el.clearBtn.addEventListener('click', ()=>{
  // Limpiar el JSON y el estado
  el.jsonin.value = '';
  el.jsonin.classList.remove('error');
  state.originalParsed = null;
  state.originalRows = []; 
  state.currentRows = []; 
  state.currentHeaders = [];
  
  // Limpiar filtros
  if(el.filterGlobal) {
    el.filterGlobal.value = '';
  }
  state.columnFilters = {};
  
  // Limpiar la tabla
  el.tableWrap.innerHTML = '';
  
  // Ocultar el área de raw si está visible
  if(el.rawDisplay && el.rawDisplay.style.display === 'block') {
    el.rawDisplay.style.display = 'none';
    el.tableWrap.style.display = '';
    el.toggleRawBtn.textContent = t('showRaw');
    // Mostrar controles nuevamente
    if(el.filterGlobal && el.filterGlobal.parentElement) {
      el.filterGlobal.parentElement.style.display = '';
    }
    if(el.filterGlobalClearBtn) el.filterGlobalClearBtn.style.display = '';
    if(el.editBtn) el.editBtn.style.display = '';
  }
  
  // Actualizar la interfaz
  updateActionButtons();
  localStorage.removeItem('lastJson');
  el.jsonin.focus();
});

const debFilterGlobal = debounce(()=>{ 
  const currentValue = el.filterGlobal?.value || '';
  try {
    localStorage.setItem('globalFilter', currentValue);
  } catch (e) {
    console.warn('No se pudo guardar el filtro global:', e);
  }
  console.log('Aplicando filtro global:', currentValue);
  renderTable(); 
  updateActionButtons(); 
}, state.filterDebounceMs);

el.filterGlobal.addEventListener('input', debFilterGlobal);

el.filterGlobalClearBtn.addEventListener('click', ()=>{
  el.filterGlobal.value = '';
  el.filterGlobal.focus();
  renderTable();
  announce('globalFilterCleared');
  try {
    localStorage.removeItem('globalFilter');
  } catch (e) {
    console.warn('No se pudo eliminar el filtro global persistido:', e);
  }
});

el.editBtn.addEventListener('click', ()=>{
  state.editing = !state.editing;
  el.editBtn.classList.toggle('active', state.editing);
  if(el.editBtnText) el.editBtnText.textContent = state.editing ? t('save') : t('edit');
  if(!state.editing) saveLastJson();
  document.body.classList.toggle('edit-mode-active', state.editing);
  const badge = document.getElementById('editModeBadge');
  if(badge){
    if(state.editing){
      badge.setAttribute('aria-hidden', 'false');
      // Reiniciar el contador al activar la edición
      resetEditTracking();
      announce('editModeActive');
    } else {
      badge.setAttribute('aria-hidden', 'true');
      announce('editModeInactive');
    }
  }
  renderTable();
});

el.fetchBtn.addEventListener('click', async ()=>{
  if(!el.urlIn.value.trim()) return;
  
  // Guardar valores actuales para restaurarlos después
  const originalBtnText = el.fetchBtn.textContent;
  const originalBtnDisabled = el.fetchBtn.disabled;
  const originalUrlDisabled = el.urlIn.disabled;
  
  // Función para restaurar el estado original
  const restoreState = () => {
    el.fetchBtn.disabled = originalBtnDisabled;
    el.fetchBtn.style.opacity = originalBtnDisabled ? '0.6' : '1';
    el.fetchBtn.textContent = originalBtnText;
    el.urlIn.disabled = originalUrlDisabled;
    el.urlIn.style.opacity = originalUrlDisabled ? '0.6' : '1';
    updateFetchButtonState();
  };
  
  try {
    // Deshabilitar temporalmente los controles
    el.fetchBtn.disabled = true;
    el.fetchBtn.style.opacity = '0.6';
    el.fetchBtn.textContent = t('loading');
    
    el.urlIn.disabled = true;
    el.urlIn.style.opacity = '0.6';
    
    const rawUrl = el.urlIn.value.trim();
    const targetUrl = normalizeUrl(rawUrl);
    const res = await fetchWithFallback(targetUrl, rawUrl);
    const txt = await res.text();
    const parsed = tryParseJson(txt);
    el.jsonin.value = parsed ? JSON.stringify(parsed, null, 2) : txt;
    state.lastParsedFull = parsed;
    await parseJsonInput(true);
    clearAllFilters();
    updateLastJsonStorage(el.jsonin.value);
    
    // Mantener deshabilitado por 1 segundo
    setTimeout(restoreState, 1000);
  } catch(e) { 
    console.warn(e);
    // Restaurar estado de los controles primero
    restoreState();
    
    // Mostrar mensaje de error en el área de la tabla
    el.tableWrap.innerHTML = `
      <div class="error-message" style="
        padding: 20px; 
        color: #ff6b6b; 
        text-align: center;
        font-size: 1.1em;
        border: 1px solid #ff6b6b;
        border-radius: 6px;
        margin: 10px 0;
        background-color: rgba(255, 107, 107, 0.1);
      ">
        URL Inválida o no se pudo cargar el recurso
      </div>`;
    
    // Resaltar el campo de URL en rojo
    el.urlIn.style.borderColor = '#ff6b6b';
    el.urlIn.style.boxShadow = '0 0 0 2px rgba(255, 107, 107, 0.2)';
    
    // Quitar el resaltado después de 3 segundos
    setTimeout(() => {
      el.urlIn.style.borderColor = '';
      el.urlIn.style.boxShadow = '';
    }, 3000);
    
    restoreState();
  }
});

el.downloadSelect.addEventListener('change', ()=>{
  const val = el.downloadSelect.value;
  if(!val) return;
  const sep = el.separatorSelect.value;

  if(val === 'csv' || val === 'txt'){
    const content = rowsToCsv(state.currentRows, sep);
    const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a'); 
    a.href = URL.createObjectURL(blob); 
    a.download = dynamicFilename(val); 
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  } else if(val === 'xlsx'){
    const ws = XLSX.utils.json_to_sheet(state.currentRows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
    XLSX.writeFile(wb, dynamicFilename(val));
  }
  el.downloadSelect.value = '';
});

el.toggleRawBtn.addEventListener('click', ()=>{
  if(!state.currentRows || !state.currentRows.length) return;

  if(el.rawDisplay.style.display === 'block'){ 
    // Mostrar tabla y controles
    el.rawDisplay.style.display = 'none'; 
    el.tableWrap.style.display = '';
    el.toggleRawBtn.textContent = t('showRaw');
    // Mostrar controles
    el.filterGlobal.parentElement.style.display = '';
    el.filterGlobalClearBtn.style.display = '';
    el.editBtn.style.display = '';
  } else {
    // Mostrar raw y ocultar controles
    el.rawDisplay.value = rowsToCsv(state.currentRows, el.separatorSelect.value);
    el.rawDisplay.style.display = 'block'; 
    el.tableWrap.style.display = 'none';
    el.toggleRawBtn.textContent = t('hideRaw');
    // Ocultar controles
    el.filterGlobal.parentElement.style.display = 'none';
    el.filterGlobalClearBtn.style.display = 'none';
    el.editBtn.style.display = 'none';
    // Seleccionar texto automáticamente
    setTimeout(()=>{ el.rawDisplay.select(); }, 20);
  }
});

el.separatorSelect.addEventListener('change', ()=>{
  if(el.rawDisplay.style.display === 'block' && state.currentRows && state.currentRows.length){
    el.rawDisplay.value = rowsToCsv(state.currentRows, el.separatorSelect.value);
    setTimeout(()=>{ el.rawDisplay.select(); }, 20);
  }
});

el.configBtn.addEventListener('click', ()=> {
  const willOpen = !el.drawer.classList.contains('open');
  toggleDrawer(willOpen);
});

el.drawerCloseBtn.addEventListener('click', ()=> {
  toggleDrawer(false);
});

if(el.drawerOverlay){
  el.drawerOverlay.addEventListener('click', ()=>{
    toggleDrawer(false);
  });
}

document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && el.drawer.classList.contains('open')){
    e.preventDefault();
    toggleDrawer(false);
  }
});

el.tabConfig.addEventListener('click', showConfigTab);
el.tabCustom.addEventListener('click', showCustomTab);

if(el.themePresetToggle){
  el.themePresetToggle.addEventListener('click', toggleThemePresetDropdown);
}

document.addEventListener('click', (event)=>{
  if(!el.themePresetDropdown || !el.themePresetToggle) return;
  if(el.themePresetDropdown.hidden) return;
  if(el.themePresetToggle.contains(event.target)) return;
  if(el.themePresetDropdown.contains(event.target)) return;
  closeThemePresetDropdown();
});

if(el.jsonHistoryToggle){
  el.jsonHistoryToggle.addEventListener('click', toggleHistoryDropdown);
}

document.addEventListener('click', (event)=>{
  if(!el.jsonHistoryDropdown || !el.jsonHistoryToggle) return;
  if(el.jsonHistoryDropdown.hidden) return;
  if(el.jsonHistoryToggle.contains(event.target)) return;
  if(el.jsonHistoryDropdown.contains(event.target)) return;
  closeHistoryDropdown();
});

if(el.languageToggle){
  el.languageToggle.addEventListener('click', toggleLanguageDropdown);
}

document.addEventListener('click', (event)=>{
  if(!el.languageDropdown || !el.languageToggle) return;
  if(el.languageDropdown.hidden) return;
  if(el.languageToggle.contains(event.target)) return;
  if(el.languageDropdown.contains(event.target)) return;
  closeLanguageDropdown();
});

el.mobileSwitchBtn.addEventListener('click', ()=>{
  enableMobileMode(!state.mobileMode);
});
['bgColor','textColor','headerColor','fontFamily','cellEven','cellOdd'].forEach(id=>{
  const node = el[id] || document.getElementById(id);
  if(node){
    node.addEventListener('input', ()=>{
      saveCustomTheme();
    });
  }
});

// Evento especial para fontSize que actualiza la altura de fila
const fontSizeNode = el.fontSize || document.getElementById('fontSize');
if(fontSizeNode){
  fontSizeNode.addEventListener('input', ()=>{
    saveCustomTheme();
    updateRowHeight();
    if(state.currentRows && state.currentRows.length > 0){
      renderTable();
    }
  });
}

el.tabConfig.addEventListener('click', showConfigTab);
el.tabCustom.addEventListener('click', showCustomTab);

el.themeLight.addEventListener('click', ()=> {
  localStorage.setItem('theme','light');
  document.body.classList.remove('dark');
  loadCustomTheme();
  updateRowHeight();
  renderTable();
});

if(el.themeDark){
  el.themeDark.addEventListener('click', ()=> {
    localStorage.setItem('theme','dark');
    document.body.classList.add('dark');
    loadCustomTheme();
    updateRowHeight();
    renderTable();
  });
}

if(el.customSaveBtn){
  el.customSaveBtn.addEventListener('click', ()=>{
    const name = prompt(t('saveThemePrompt') || 'Nombre para el tema');
    if(name === null) return;
    const saved = saveThemePreset(name);
    if(saved && el.themePresetSelected){
      el.themePresetSelected.textContent = name.trim() || t('themePresetPlaceholder');
    }
    closeThemePresetDropdown();
  });
}

el.customDefaultBtn.addEventListener('click', ()=>{
  if(!confirm(t('resetThemeConfirm'))) return;
  const isDark = document.body.classList.contains('dark');
  const themeKey = 'customTheme_' + (isDark ? 'dark' : 'light');
  const defaults = isDark ? {
    bg: '#141414',
    text: '#EEEEEE',
    header: '#222222',
    cellEven: '#252525',
    cellOdd: '#202020',
    font: "'Segoe UI', Tahoma, sans-serif",
    fontSize: '12'
  } : {
    bg: '#ffffff',
    text: '#111111',
    header: '#f2f2f2',
    cellEven: '#f9f9f9',
    cellOdd: '#eef3ff',
    font: "'Segoe UI', Tahoma, sans-serif",
    fontSize: '12'
  };
  el.bgColor.value = defaults.bg;
  el.textColor.value = defaults.text;
  el.headerColor.value = defaults.header;
  el.cellEven.value = defaults.cellEven;
  el.cellOdd.value = defaults.cellOdd;
  el.fontFamily.value = defaults.font;
  if(el.fontSize) el.fontSize.value = defaults.fontSize;
  localStorage.removeItem(themeKey);
  const storedDefaults = saveCustomTheme({
    ...defaults,
    fontSize: Number(defaults.fontSize)
  });
  applyCustomTheme(storedDefaults);
  document.documentElement.style.setProperty('--font-main', storedDefaults.font);
  document.documentElement.style.setProperty('--custom-font-size', `${storedDefaults.fontSize}px`);
  state.selectedThemePreset = '';
  loadThemePresets();
});

el.urlIn.addEventListener('input', updateFetchButtonState);

el.urlClearBtn.addEventListener('click', ()=>{
  el.urlIn.value = '';
  // Restaurar estilos del campo de URL
  resetUrlVisualState();
  updateFetchButtonState();
  updateClearButtons();
  el.urlIn.focus();
});

el.jsonin.addEventListener('input', async ()=>{
  updateActionButtons();
  
  if (window.jsonInputDebounce) {
    clearTimeout(window.jsonInputDebounce);
  }

  window.jsonInputDebounce = setTimeout(async () => {
    try {
      await parseJsonInput(false);
    } catch (e) {
      console.error('Error al procesar JSON:', e);
    }
  }, 500);
});

document.addEventListener('click', (e) => {
  if (e.target && e.target.classList.contains('filter-col-clear')) {
    const col = decodeURIComponent(e.target.dataset.col || '');
    state.columnFilters[col] = '';
    const input = document.querySelector(`.filter-col[data-col="${encodeURIComponent(col)}"]`);
    if (input) {
      input.value = '';
      input.focus();
    }
    updateClearButtons();
    renderTable();
  }
});

window.addEventListener('resize', () => {
  computeVisibleCount();
  renderTable();
});

// Configurar manejador de eventos para el selector de idioma
if (el.languageSelect) {
  el.languageSelect.addEventListener('change', function(e) {
    console.log('Idioma cambiado a:', this.value);
    changeLanguage(this.value);
  });
}

// Inicializar botones de limpieza
document.addEventListener('DOMContentLoaded', initClearButtons);

// Si el DOM ya está cargado, inicializar de inmediato
if (document.readyState !== 'loading') {
  initClearButtons();
}

// Evento para el botón copiar tabla
el.copyBtn.addEventListener('click', (e)=>{
  if(!state.currentRows || !state.currentRows.length) return;

  const sep = el.separatorSelect.value;
  const content = rowsToCsv(state.currentRows, sep);
  
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(content).then(()=>{
      console.log('Tabla copiada al portapapeles');
      announce('tableCopied');
      showCopyMessage(e.clientX, e.clientY);
    }).catch(err=>{
      console.error('Error al copiar al portapapeles:', err);
      // Fallback para navegadores antiguos
      const textArea = document.createElement('textarea');
      textArea.value = content;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      announce('tableCopied');
      showCopyMessage(e.clientX, e.clientY);
    });
  } else {
    // Fallback para navegadores antiguos
    const textArea = document.createElement('textarea');
    textArea.value = content;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    announce('tableCopied');
    showCopyMessage(e.clientX, e.clientY);
  }
});

function showCopyMessage(x, y) {
  const msg = document.getElementById('copyMessage');
  if (msg) {
    msg.style.left = `${x + 10}px`; // 10px a la derecha del mouse
    msg.style.top = `${y + 10}px`; // 10px abajo del mouse
    msg.style.display = 'block';
    setTimeout(() => {
      msg.style.display = 'none';
    }, 2000); // Ocultar después de 2 segundos
  }
}
</script>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
